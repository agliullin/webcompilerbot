/* parser generated by jison 0.4.2 */
var parse = (function(){
    var parser = {trace: function trace() { },
        yy: {},
        symbols_: {"error":2,"program":3,"program_header":4,"block":5,"DOT":6,"PROGRAM":7,"id":8,"SEMI":9,"uses":10,"LPAREN":11,"ids":12,"RPAREN":13,"decls":14,"cstmt":15,"use_decl":16,"USES":17,"decl":18,"CONST":19,"const_decls":20,"TYPE":21,"type_decls":22,"VAR":23,"var_decls":24,"PROCEDURE":25,"proc_decl":26,"FUNCTION":27,"func_decl":28,"const_decl":29,"EQ":30,"expr":31,"COLON":32,"type":33,"type_decl":34,"INTEGER":35,"REAL":36,"BOOLEAN":37,"CHAR":38,"BYTE":39,"ordinal_type":40,"structured_type":41,"STRING":42,"LBRACK":43,"INTEGER_LITERAL":44,"RBRACK":45,"ARRAY":46,"indexes":47,"OF":48,"RECORD":49,"rec_sections":50,"END":51,"enumerated_type":52,"subrange":53,"literal_ids":54,"COMMA":55,"constant":56,"DOTDOT":57,"constant_num":58,"character":59,"rec_section":60,"var_decl":61,"formal_params":62,"FORWARD":63,"fp_sections":64,"fp_section":65,"BEGIN":66,"stmts":67,"stmt":68,"open_stmt":69,"closed_stmt":70,"lvalue":71,"ASSIGN":72,"call_params":73,"closed_if_stmt":74,"case_stmt":75,"closed_for_stmt":76,"repeat_stmt":77,"closed_while_stmt":78,"open_if_stmt":79,"open_for_stmt":80,"open_while_stmt":81,"REPEAT":82,"UNTIL":83,"IF":84,"THEN":85,"ELSE":86,"WHILE":87,"DO":88,"FOR":89,"TO":90,"DOWNTO":91,"CASE":92,"cases":93,"OTHERWISE":94,"case":95,"case_indexes":96,"case_index":97,"exprs":98,"REAL_LITERAL":99,"STRING_LITERAL":100,"CARET":101,"MINUS":102,"NOT":103,"PLUS":104,"STAR":105,"SLASH":106,"DIV":107,"MOD":108,"OR":109,"AND":110,"GT":111,"LT":112,"GEQ":113,"LEQ":114,"NEQ":115,"ID":116,"CHARACTER_LITERAL":117,"literal_id":118,"$accept":0,"$end":1},
        terminals_: {2:"error",6:"DOT",7:"PROGRAM",9:"SEMI",11:"LPAREN",13:"RPAREN",17:"USES",19:"CONST",21:"TYPE",23:"VAR",25:"PROCEDURE",27:"FUNCTION",30:"EQ",32:"COLON",35:"INTEGER",36:"REAL",37:"BOOLEAN",38:"CHAR",39:"BYTE",42:"STRING",43:"LBRACK",44:"INTEGER_LITERAL",45:"RBRACK",46:"ARRAY",48:"OF",49:"RECORD",51:"END",55:"COMMA",57:"DOTDOT",63:"FORWARD",66:"BEGIN",72:"ASSIGN",82:"REPEAT",83:"UNTIL",84:"IF",85:"THEN",86:"ELSE",87:"WHILE",88:"DO",89:"FOR",90:"TO",91:"DOWNTO",92:"CASE",94:"OTHERWISE",99:"REAL_LITERAL",100:"STRING_LITERAL",101:"CARET",102:"MINUS",103:"NOT",104:"PLUS",105:"STAR",106:"SLASH",107:"DIV",108:"MOD",109:"OR",110:"AND",111:"GT",112:"LT",113:"GEQ",114:"LEQ",115:"NEQ",116:"ID",117:"CHARACTER_LITERAL"},
        productions_: [0,[3,3],[4,4],[4,3],[4,7],[4,6],[5,2],[5,1],[10,2],[10,1],[16,3],[14,2],[14,1],[18,3],[18,3],[18,3],[18,3],[18,3],[20,3],[20,1],[29,3],[29,5],[22,3],[22,1],[34,3],[33,1],[33,1],[33,1],[33,1],[33,1],[33,1],[33,1],[41,1],[41,4],[41,6],[41,3],[41,4],[40,1],[40,1],[40,1],[52,3],[47,3],[47,1],[53,3],[53,3],[53,3],[53,3],[56,1],[56,1],[50,3],[50,1],[60,3],[24,3],[24,1],[61,3],[26,4],[26,3],[26,4],[26,3],[26,0],[28,6],[28,5],[28,6],[28,5],[28,0],[62,3],[62,2],[64,3],[64,1],[65,3],[65,4],[15,3],[15,4],[67,3],[67,1],[67,0],[68,1],[68,1],[70,3],[70,2],[70,1],[70,1],[70,1],[70,1],[70,1],[70,1],[70,1],[69,1],[69,1],[69,1],[77,4],[77,5],[74,6],[79,4],[79,6],[78,4],[81,4],[76,8],[76,8],[80,8],[80,8],[75,5],[75,6],[75,7],[75,8],[75,8],[75,9],[93,3],[93,1],[95,3],[96,3],[96,1],[97,1],[97,1],[98,3],[98,1],[31,1],[31,1],[31,1],[31,1],[31,1],[31,2],[31,3],[31,2],[31,2],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,2],[31,2],[31,2],[73,3],[73,2],[71,1],[71,4],[71,3],[12,3],[12,1],[8,1],[58,1],[58,2],[59,1],[54,3],[54,1],[118,1]],
        performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

            var $0 = $$.length - 1;
            switch (yystate) {
                case 1: $$[$0-1].uses = $$[$0-2].uses;
                    this.$ = {node:'program',id:$$[$0-2].id,fparams:$$[$0-2].fparams,block:$$[$0-1]};
                    if (isNode() && require.main === module) {
                        inspect(this.$);
                    }
                    return this.$;
                    break;
                case 2: this.$ = {node:'program_heading',id:$$[$0-2],fparams:[],uses:$$[$0]};
                    break;
                case 3: this.$ = {node:'program_heading',id:$$[$0-1],fparams:[],uses:[]};
                    break;
                case 4: this.$ = {node:'program_heading',id:$$[$0-5],fparams:$$[$0-3],uses:$$[$0]};
                    break;
                case 5: this.$ = {node:'program_heading',id:$$[$0-4],fparams:$$[$0-2],uses:[]};
                    break;
                case 6: this.$ = {node:'block',decls:$$[$0-1],stmts:$$[$0]};
                    break;
                case 7: this.$ = {node:'block',decls:[],stmts:$$[$0]};
                    break;
                case 8: this.$ = $$[$0-1].concat($$[$0]);
                    break;
                case 9: this.$ = $$[$0];
                    break;
                case 10: this.$ = $$[$0-1];
                    break;
                case 11: this.$ = $$[$0-1].concat($$[$0]);
                    break;
                case 12: this.$ = $$[$0];
                    break;
                case 13: this.$ = $$[$0-1];
                    break;
                case 14: this.$ = $$[$0-1];
                    break;
                case 15: this.$ = $$[$0-1];
                    break;
                case 16: this.$ = [$$[$0-1]];
                    break;
                case 17: this.$ = [$$[$0-1]];
                    break;
                case 18: this.$ = $$[$0-2].concat($$[$0]);
                    break;
                case 19: this.$ = [$$[$0]];
                    break;
                case 20: this.$ = {node:'const_decl',id:$$[$0-2],expr:$$[$0],lineno:yylineno};
                    break;
                case 21: this.$ = {node:'const_decl',id:$$[$0-4],type:$$[$0-2],expr:$$[$0],lineno:yylineno};
                    break;
                case 22: this.$ = $$[$0-2].concat($$[$0]);
                    break;
                case 23: this.$ = [$$[$0]];
                    break;
                case 24: this.$ = {node:'type_decl',id:$$[$0-2],type:$$[$0],lineno:yylineno};
                    break;
                case 25: this.$ = {node:'type',name:'INTEGER'};
                    break;
                case 26: this.$ = {node:'type',name:'REAL'};
                    break;
                case 27: this.$ = {node:'type',name:'BOOLEAN'};
                    break;
                case 28: this.$ = {node:'type',name:'CHARACTER'};
                    break;
                case 29: this.$ = {node:'type',name:'BYTE'};
                    break;
                case 30: this.$ = $$[$0];
                    break;
                case 31: this.$ = $$[$0];
                    break;
                case 32: this.$ = {node:'type',name:'STRING'};
                    this.$.type = {node:'type',name:'CHARACTER'};
                    this.$.index ={start:1};
                    break;
                case 33: this.$ = {node:'type',name:'STRING'};
                    this.$.type = {node:'type',name:'CHARACTER'};
                    this.$.index ={start:1,end:parseInt($$[$0-1]) };
                    break;
                case 34: this.$ = $$[$0];
                    for(var i=$$[$0-3].length-1; i >= 0; i--) {
                        this.$ = {node:'type',name:'ARRAY',type:this.$,index:$$[$0-3][i]}; }
                    break;
                case 35: this.$ = {node:'type',name:'RECORD',sections:$$[$0-1]};
                    break;
                case 36: this.$ = {node:'type',name:'RECORD',sections:$$[$0-2]};
                    break;
                case 37: this.$ = $$[$0];
                    break;
                case 38: this.$ = {node:'type',name:'NAMED',id:$$[$0]};
                    break;
                case 39: this.$ = $$[$0]; this.$.node = 'type'; this.$.name = 'SUBRANGE';
                    break;
                case 40: this.$ = {node:'type',name:'ENUMERATION',ids:$$[$0-1]};
                    break;
                case 41: this.$ = $$[$0-2].concat($$[$0]);
                    break;
                case 42: this.$ = [$$[$0]];
                    break;
                case 43: this.$ = {node:'subrange',start:$$[$0-2],end:$$[$0]};
                    break;
                case 44: this.$ = {node:'subrange',start:{node:'constant',stype:'variable',val:$$[$0-2]},end:$$[$0]};
                    break;
                case 45: this.$ = {node:'subrange',start:$$[$0-2],end:{node:'constant',stype:'variable',val:$$[$0]} };
                    break;
                case 46: this.$ = {node:'subrange',start:{node:'constant',stype:'variable',val:$$[$0-2] },end:{node:'constant',stype:'variable',val:$$[$0]} };
                    break;
                case 47: this.$ = {node:'constant',stype:'INTEGER',val:$$[$0].val};
                    break;
                case 48: this.$ = {node:'constant',stype:'CHARACTER',val:$$[$0].val};
                    break;
                case 49: this.$ = $$[$0-2].concat($$[$0]);
                    break;
                case 50: this.$ = $$[$0];
                    break;
                case 51: this.$ = [];
                    for(var i=0; i < $$[$0-2].length; i++) {
                        this.$ = this.$.concat([{node:'component',id:$$[$0-2][i],type:$$[$0]}]); }
                    break;
                case 52: this.$ = $$[$0-2].concat($$[$0]);
                    break;
                case 53: this.$ = $$[$0];
                    break;
                case 54: this.$ = [];
                    for(var i=0; i < $$[$0-2].length; i++) {
                        this.$ = this.$.concat([{node:'var_decl',id:$$[$0-2][i],type:$$[$0],lineno:yylineno}]); }
                    break;
                case 55: this.$ = {node:'proc_decl',id:$$[$0-3],fparams:$$[$0-2],block:$$[$0],lineno:yylineno};
                    break;
                case 56: this.$ = {node:'proc_decl',id:$$[$0-2],fparams:[],block:$$[$0],lineno:yylineno};
                    break;
                case 57: this.$ = {node:'proc_decl',id:$$[$0-3],fparams:$$[$0-2],block:'forward',lineno:yylineno};
                    break;
                case 58: this.$ = {node:'proc_decl',id:$$[$0-2],fparams:[],block:'forward',lineno:yylineno};
                    break;
                case 60: this.$ = {node:'func_decl',id:$$[$0-5],fparams:$$[$0-4],type:$$[$0-2],block:$$[$0],lineno:yylineno};
                    break;
                case 61: this.$ = {node:'func_decl',id:$$[$0-4],fparams:[],type:$$[$0-2],block:$$[$0],lineno:yylineno};
                    break;
                case 62: this.$ = {node:'func_decl',id:$$[$0-5],fparams:$$[$0-4],type:$$[$0-2],block:'forward',lineno:yylineno};
                    break;
                case 63: this.$ = {node:'func_decl',id:$$[$0-4],fparams:[],type:$$[$0-2],block:'forward',lineno:yylineno};
                    break;
                case 65: this.$ = $$[$0-1];
                    break;
                case 66: this.$ = [];
                    break;
                case 67: this.$ = $$[$0-2].concat($$[$0]);
                    break;
                case 68: this.$ = $$[$0];
                    break;
                case 69: this.$ = [];
                    for(var i=0; i < $$[$0-2].length; i++) {
                        this.$ = this.$.concat([{node:'param',id:$$[$0-2][i],type:$$[$0],var:false}]); }
                    break;
                case 70: this.$ = [];
                    for(var i=0; i < $$[$0-2].length; i++) {
                        this.$ = this.$.concat([{node:'param',id:$$[$0-2][i],type:$$[$0],var:true}]); }
                    break;
                case 71: this.$ = $$[$0-1];
                    break;
                case 72: this.$ = $$[$0-2];
                    break;
                case 73: this.$ = $$[$0-2].concat($$[$0]);
                    break;
                case 74: this.$ = [$$[$0]];
                    break;
                case 75: this.$ = [];
                    break;
                case 76: $$[$0].lineno = yylineno; this.$ = $$[$0];
                    break;
                case 77: $$[$0].lineno = yylineno; this.$ = $$[$0];
                    break;
                case 78: this.$ = {node:'stmt_assign',lvalue:$$[$0-2],expr:$$[$0]};
                    break;
                case 79: this.$ = {node:'stmt_call',id:$$[$0-1],call_params:$$[$0]};
                    break;
                case 80: this.$ = {node:'stmt_call',id:$$[$0].id,call_params:[]};
                    break;
                case 81: this.$ = {node:'stmt_compound',stmts:$$[$0]};
                    break;
                case 82: this.$ = $$[$0];
                    break;
                case 83: this.$ = $$[$0];
                    break;
                case 84: this.$ = $$[$0];
                    break;
                case 85: this.$ = $$[$0];
                    break;
                case 86: this.$ = $$[$0];
                    break;
                case 87: this.$ = $$[$0];
                    break;
                case 88: this.$ = $$[$0];
                    break;
                case 89: this.$ = $$[$0];
                    break;
                case 90: this.$ = {node:'stmt_repeat',expr:$$[$0],stmts:$$[$0-2]};
                    break;
                case 91: this.$ = {node:'stmt_repeat',expr:$$[$0],stmts:$$[$0-3]};
                    break;
                case 92: this.$ = {node:'stmt_if',expr:$$[$0-4],tstmt:$$[$0-2],fstmt:$$[$0]};
                    break;
                case 93: this.$ = {node:'stmt_if',expr:$$[$0-2],tstmt:$$[$0],fstmt:null};
                    break;
                case 94: this.$ = {node:'stmt_if',expr:$$[$0-4],tstmt:$$[$0-2],fstmt:$$[$0]};
                    break;
                case 95: this.$ = {node:'stmt_while',expr:$$[$0-2],stmt:$$[$0]};
                    break;
                case 96: this.$ = {node:'stmt_while',expr:$$[$0-2],stmt:$$[$0]};
                    break;
                case 97: this.$ = {node:'stmt_for',index:$$[$0-6],start:$$[$0-4],by:1, end:$$[$0-2],stmt:$$[$0]};
                    break;
                case 98: this.$ = {node:'stmt_for',index:$$[$0-6],start:$$[$0-4],by:-1,end:$$[$0-2],stmt:$$[$0]};
                    break;
                case 99: this.$ = {node:'stmt_for',index:$$[$0-6],start:$$[$0-4],by:1, end:$$[$0-2],stmt:$$[$0]};
                    break;
                case 100: this.$ = {node:'stmt_for',index:$$[$0-6],start:$$[$0-4],by:-1,end:$$[$0-2],stmt:$$[$0]};
                    break;
                case 101: this.$ = {node:'stmt_case',expr:$$[$0-3],cases:$$[$0-1],otherwise_stmt:[]};
                    break;
                case 102: this.$ = {node:'stmt_case',expr:$$[$0-4],cases:$$[$0-2],otherwise_stmt:[]};
                    break;
                case 103: this.$ = {node:'stmt_case',expr:$$[$0-5],cases:$$[$0-3],otherwise_stmt:$$[$0-1]};
                    break;
                case 104: this.$ = {node:'stmt_case',expr:$$[$0-6],cases:$$[$0-4],otherwise_stmt:$$[$0-2]};
                    break;
                case 105: this.$ = {node:'stmt_case',expr:$$[$0-6],cases:$$[$0-4],otherwise_stmt:$$[$0-2]};
                    break;
                case 106: this.$ = {node:'stmt_case',expr:$$[$0-7],cases:$$[$0-5],otherwise_stmt:$$[$0-2]};
                    break;
                case 107: this.$ = $$[$0-2].concat($$[$0]);
                    break;
                case 108: this.$ = [$$[$0]];
                    break;
                case 109: this.$ = {node:'case',indexes:$$[$0-2],stmt:$$[$0]};
                    break;
                case 110: this.$ = $$[$0-2].concat([$$[$0]]);
                    break;
                case 111: this.$ = [$$[$0]];
                    break;
                case 112: this.$ = $$[$0];
                    break;
                case 113: this.$ = $$[$0];
                    break;
                case 114: this.$ = $$[$0-2].concat([$$[$0]]);
                    break;
                case 115: this.$ = [$$[$0]];
                    break;
                case 116: this.$ = {node:'integer',type:{node:'type',name:'INTEGER'},val:parseInt($$[$0])};
                    break;
                case 117: this.$ = {node:'real',type:{node:'type',name:'REAL'},val:parseFloat($$[$0])};
                    break;
                case 118: var raw = $$[$0].substr(1,$$[$0].length-2),
                    re = /''/g,
                    val = raw.replace(re, "'");
                    this.$ = {node:'string',val:val,type:{node:'type',name:'STRING'},
                        index:{node:'subrange',start:1,end:val.length+1 } };
                    break;
                case 119: this.$ = $$[$0];
                    break;
                case 120: this.$ = $$[$0];
                    break;
                case 121: this.$ = {node:'pointer',type:{node:'type',name:'POINTER'},id:$$[$0]};
                    break;
                case 122: this.$ = $$[$0-1];
                    break;
                case 123: this.$ = {node:'expr_unop',op:'minus',expr:$$[$0]};
                    break;
                case 124: this.$ = {node:'expr_unop',op:'not',expr:$$[$0]};
                    break;
                case 125: this.$ = {node:'expr_binop',op:'plus',left:$$[$0-2],right:$$[$0]};
                    break;
                case 126: this.$ = {node:'expr_binop',op:'minus',left:$$[$0-2],right:$$[$0]};
                    break;
                case 127: this.$ = {node:'expr_binop',op:'star',left:$$[$0-2],right:$$[$0]};
                    break;
                case 128: this.$ = {node:'expr_binop',op:'slash',left:$$[$0-2],right:$$[$0]};
                    break;
                case 129: this.$ = {node:'expr_binop',op:'div',left:$$[$0-2],right:$$[$0]};
                    break;
                case 130: this.$ = {node:'expr_binop',op:'mod',left:$$[$0-2],right:$$[$0]};
                    break;
                case 131: this.$ = {node:'expr_binop',op:'or',left:$$[$0-2],right:$$[$0]};
                    break;
                case 132: this.$ = {node:'expr_binop',op:'and',left:$$[$0-2],right:$$[$0]};
                    break;
                case 133: this.$ = {node:'expr_binop',op:'gt',left:$$[$0-2],right:$$[$0]};
                    break;
                case 134: this.$ = {node:'expr_binop',op:'lt',left:$$[$0-2],right:$$[$0]};
                    break;
                case 135: this.$ = {node:'expr_binop',op:'eq',left:$$[$0-2],right:$$[$0]};
                    break;
                case 136: this.$ = {node:'expr_binop',op:'geq',left:$$[$0-2],right:$$[$0]};
                    break;
                case 137: this.$ = {node:'expr_binop',op:'leq',left:$$[$0-2],right:$$[$0]};
                    break;
                case 138: this.$ = {node:'expr_binop',op:'neq',left:$$[$0-2],right:$$[$0]};
                    break;
                case 139: this.$ = {node:'expr_call',id:$$[$0-1].toUpperCase(),call_params:$$[$0]};
                    break;
                case 140: this.$ = {node:'expr_call',id:$$[$0-1].toUpperCase(),call_params:$$[$0]};
                    break;
                case 141: this.$ = {node:'expr_call',id:$$[$0-1].id,call_params:$$[$0]};
                    break;
                case 142: this.$ = $$[$0-1];
                    break;
                case 143: this.$ = [];
                    break;
                case 144: this.$ = {node:'variable',id:$$[$0]};
                    break;
                case 145: this.$ = $$[$0-3];
                    for(var i=0; i < $$[$0-1].length; i++) {
                        this.$ = {node:'expr_array_deref',lvalue:this.$,expr:$$[$0-1][i]} }
                    break;
                case 146: this.$ = {node:'expr_record_deref',lvalue:$$[$0-2],component:$$[$0]};
                    break;
                case 147: this.$ = $$[$0-2].concat([$$[$0]]);
                    break;
                case 148: this.$ = [$$[$0]];
                    break;
                case 149: this.$ = yytext.toUpperCase();
                    break;
                case 150: this.$ = {node:'integer',type:{node:'type',name:'INTEGER'},val:parseInt($$[$0])};
                    break;
                case 151: this.$ = {node:'integer',type:{node:'type',name:'INTEGER'},val:-parseInt($$[$0-1])};
                    break;
                case 152: this.$ = {node:'character',type:{node:'type',name:'CHARACTER'} };
                    if ($$[$0][0] === "'") {
                        this.$.val = $$[$0].substr(1,$$[$0].length-2).charCodeAt(0);
                    } else {
                        this.$.val = parseInt($$[$0].substr(1),10);
                    }
                    break;
                case 153: this.$ = $$[$0-2].concat([$$[$0]]);
                    break;
                case 154: this.$ = [$$[$0]];
                    break;
                case 155: this.$ = yytext;
                    break;
            }
        },
        table: [{3:1,4:2,7:[1,3]},{1:[3]},{5:4,14:5,15:6,18:7,19:[1,9],21:[1,10],23:[1,11],25:[1,12],27:[1,13],66:[1,8]},{8:14,116:[1,15]},{6:[1,16]},{15:17,18:18,19:[1,9],21:[1,10],23:[1,11],25:[1,12],27:[1,13],66:[1,8]},{6:[2,7],9:[2,7]},{19:[2,12],21:[2,12],23:[2,12],25:[2,12],27:[2,12],66:[2,12]},{8:27,9:[2,75],15:28,51:[2,75],66:[1,8],67:19,68:20,69:21,70:22,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{8:41,20:39,29:40,116:[1,15]},{8:44,22:42,34:43,116:[1,15]},{8:48,12:47,24:45,61:46,116:[1,15]},{8:50,9:[2,59],26:49,116:[1,15]},{8:52,9:[2,64],28:51,116:[1,15]},{9:[1,53],11:[1,54]},{6:[2,149],9:[2,149],11:[2,149],13:[2,149],30:[2,149],32:[2,149],43:[2,149],45:[2,149],48:[2,149],51:[2,149],55:[2,149],57:[2,149],72:[2,149],83:[2,149],85:[2,149],86:[2,149],88:[2,149],90:[2,149],91:[2,149],94:[2,149],102:[2,149],104:[2,149],105:[2,149],106:[2,149],107:[2,149],108:[2,149],109:[2,149],110:[2,149],111:[2,149],112:[2,149],113:[2,149],114:[2,149],115:[2,149]},{1:[2,1]},{6:[2,6],9:[2,6]},{19:[2,11],21:[2,11],23:[2,11],25:[2,11],27:[2,11],66:[2,11]},{9:[1,56],51:[1,55]},{9:[2,74],51:[2,74],83:[2,74]},{9:[2,76],51:[2,76],83:[2,76],94:[2,76]},{9:[2,77],51:[2,77],83:[2,77],94:[2,77]},{9:[2,87],51:[2,87],83:[2,87],94:[2,87]},{9:[2,88],51:[2,88],83:[2,88],94:[2,88]},{9:[2,89],51:[2,89],83:[2,89],94:[2,89]},{6:[1,59],9:[2,80],43:[1,58],51:[2,80],72:[1,57],83:[2,80],86:[2,80],94:[2,80]},{6:[2,144],9:[2,144],11:[1,61],43:[2,144],51:[2,144],72:[2,144],73:60,83:[2,144],86:[2,144],94:[2,144]},{9:[2,81],51:[2,81],83:[2,81],86:[2,81],94:[2,81]},{9:[2,82],51:[2,82],83:[2,82],86:[2,82],94:[2,82]},{9:[2,83],51:[2,83],83:[2,83],86:[2,83],94:[2,83]},{9:[2,84],51:[2,84],83:[2,84],86:[2,84],94:[2,84]},{9:[2,85],51:[2,85],83:[2,85],86:[2,85],94:[2,85]},{9:[2,86],51:[2,86],83:[2,86],86:[2,86],94:[2,86]},{8:75,11:[1,69],31:62,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,71:76,116:[1,15]},{8:75,11:[1,69],31:77,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:78,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:27,9:[2,75],15:28,66:[1,8],67:79,68:20,69:21,70:22,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],83:[2,75],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{9:[1,80]},{9:[2,19]},{30:[1,81],32:[1,82]},{9:[1,83]},{9:[2,23]},{30:[1,84]},{9:[1,85]},{9:[2,53]},{32:[1,86],55:[1,87]},{9:[2,148],13:[2,148],32:[2,148],55:[2,148]},{9:[1,88]},{9:[1,90],11:[1,91],62:89},{9:[1,92]},{11:[1,91],32:[1,94],62:93},{10:95,16:96,17:[1,97],19:[2,3],21:[2,3],23:[2,3],25:[2,3],27:[2,3],66:[2,3]},{8:48,12:98,116:[1,15]},{6:[2,71],9:[2,71],51:[2,71],83:[2,71],86:[2,71],94:[2,71]},{8:27,15:28,51:[1,99],66:[1,8],68:100,69:21,70:22,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{8:75,11:[1,69],31:101,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:103,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,98:102,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:104,116:[1,15]},{9:[2,79],51:[2,79],83:[2,79],86:[2,79],94:[2,79]},{8:75,11:[1,69],13:[1,106],31:103,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,98:105,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{30:[1,118],85:[1,107],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{9:[2,116],13:[2,116],30:[2,116],45:[2,116],48:[2,116],51:[2,116],55:[2,116],83:[2,116],85:[2,116],86:[2,116],88:[2,116],90:[2,116],91:[2,116],94:[2,116],102:[2,116],104:[2,116],105:[2,116],106:[2,116],107:[2,116],108:[2,116],109:[2,116],110:[2,116],111:[2,116],112:[2,116],113:[2,116],114:[2,116],115:[2,116]},{9:[2,117],13:[2,117],30:[2,117],45:[2,117],48:[2,117],51:[2,117],55:[2,117],83:[2,117],85:[2,117],86:[2,117],88:[2,117],90:[2,117],91:[2,117],94:[2,117],102:[2,117],104:[2,117],105:[2,117],106:[2,117],107:[2,117],108:[2,117],109:[2,117],110:[2,117],111:[2,117],112:[2,117],113:[2,117],114:[2,117],115:[2,117]},{9:[2,118],13:[2,118],30:[2,118],45:[2,118],48:[2,118],51:[2,118],55:[2,118],83:[2,118],85:[2,118],86:[2,118],88:[2,118],90:[2,118],91:[2,118],94:[2,118],102:[2,118],104:[2,118],105:[2,118],106:[2,118],107:[2,118],108:[2,118],109:[2,118],110:[2,118],111:[2,118],112:[2,118],113:[2,118],114:[2,118],115:[2,118]},{9:[2,119],13:[2,119],30:[2,119],45:[2,119],48:[2,119],51:[2,119],55:[2,119],83:[2,119],85:[2,119],86:[2,119],88:[2,119],90:[2,119],91:[2,119],94:[2,119],102:[2,119],104:[2,119],105:[2,119],106:[2,119],107:[2,119],108:[2,119],109:[2,119],110:[2,119],111:[2,119],112:[2,119],113:[2,119],114:[2,119],115:[2,119]},{6:[1,59],9:[2,120],11:[1,61],13:[2,120],30:[2,120],43:[1,58],45:[2,120],48:[2,120],51:[2,120],55:[2,120],73:122,83:[2,120],85:[2,120],86:[2,120],88:[2,120],90:[2,120],91:[2,120],94:[2,120],102:[2,120],104:[2,120],105:[2,120],106:[2,120],107:[2,120],108:[2,120],109:[2,120],110:[2,120],111:[2,120],112:[2,120],113:[2,120],114:[2,120],115:[2,120]},{8:123,116:[1,15]},{8:75,11:[1,69],31:124,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:125,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:126,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{11:[1,61],73:127},{11:[1,61],73:128},{9:[2,152],13:[2,152],30:[2,152],32:[2,152],45:[2,152],48:[2,152],51:[2,152],55:[2,152],57:[2,152],83:[2,152],85:[2,152],86:[2,152],88:[2,152],90:[2,152],91:[2,152],94:[2,152],102:[2,152],104:[2,152],105:[2,152],106:[2,152],107:[2,152],108:[2,152],109:[2,152],110:[2,152],111:[2,152],112:[2,152],113:[2,152],114:[2,152],115:[2,152]},{6:[2,144],9:[2,144],11:[2,144],13:[2,144],30:[2,144],43:[2,144],45:[2,144],48:[2,144],51:[2,144],55:[2,144],72:[2,144],83:[2,144],85:[2,144],86:[2,144],88:[2,144],90:[2,144],91:[2,144],94:[2,144],102:[2,144],104:[2,144],105:[2,144],106:[2,144],107:[2,144],108:[2,144],109:[2,144],110:[2,144],111:[2,144],112:[2,144],113:[2,144],114:[2,144],115:[2,144]},{6:[1,59],43:[1,58],72:[1,129]},{30:[1,118],88:[1,130],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{30:[1,118],48:[1,131],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{9:[1,133],83:[1,132]},{8:41,19:[2,13],21:[2,13],23:[2,13],25:[2,13],27:[2,13],29:134,66:[2,13],116:[1,15]},{8:75,11:[1,69],31:135,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:145,11:[1,150],33:136,35:[1,137],36:[1,138],37:[1,139],38:[1,140],39:[1,141],40:142,41:143,42:[1,147],44:[1,154],46:[1,148],49:[1,149],52:144,53:146,56:151,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{8:44,19:[2,14],21:[2,14],23:[2,14],25:[2,14],27:[2,14],34:156,66:[2,14],116:[1,15]},{8:145,11:[1,150],33:157,35:[1,137],36:[1,138],37:[1,139],38:[1,140],39:[1,141],40:142,41:143,42:[1,147],44:[1,154],46:[1,148],49:[1,149],52:144,53:146,56:151,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{8:48,12:47,19:[2,15],21:[2,15],23:[2,15],25:[2,15],27:[2,15],61:158,66:[2,15],116:[1,15]},{8:145,11:[1,150],33:159,35:[1,137],36:[1,138],37:[1,139],38:[1,140],39:[1,141],40:142,41:143,42:[1,147],44:[1,154],46:[1,148],49:[1,149],52:144,53:146,56:151,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{8:160,116:[1,15]},{19:[2,16],21:[2,16],23:[2,16],25:[2,16],27:[2,16],66:[2,16]},{9:[1,161]},{5:162,14:5,15:6,18:7,19:[1,9],21:[1,10],23:[1,11],25:[1,12],27:[1,13],63:[1,163],66:[1,8]},{8:48,12:167,13:[1,165],23:[1,168],64:164,65:166,116:[1,15]},{19:[2,17],21:[2,17],23:[2,17],25:[2,17],27:[2,17],66:[2,17]},{32:[1,169]},{8:145,11:[1,150],33:170,35:[1,137],36:[1,138],37:[1,139],38:[1,140],39:[1,141],40:142,41:143,42:[1,147],44:[1,154],46:[1,148],49:[1,149],52:144,53:146,56:151,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{16:171,17:[1,97],19:[2,2],21:[2,2],23:[2,2],25:[2,2],27:[2,2],66:[2,2]},{17:[2,9],19:[2,9],21:[2,9],23:[2,9],25:[2,9],27:[2,9],66:[2,9]},{8:48,12:172,116:[1,15]},{13:[1,173],55:[1,87]},{6:[2,72],9:[2,72],51:[2,72],83:[2,72],86:[2,72],94:[2,72]},{9:[2,73],51:[2,73],83:[2,73]},{9:[2,78],30:[1,118],51:[2,78],83:[2,78],86:[2,78],94:[2,78],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{45:[1,174],55:[1,175]},{13:[2,115],30:[1,118],45:[2,115],55:[2,115],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{6:[2,146],9:[2,146],11:[2,146],13:[2,146],30:[2,146],43:[2,146],45:[2,146],48:[2,146],51:[2,146],55:[2,146],72:[2,146],83:[2,146],85:[2,146],86:[2,146],88:[2,146],90:[2,146],91:[2,146],94:[2,146],102:[2,146],104:[2,146],105:[2,146],106:[2,146],107:[2,146],108:[2,146],109:[2,146],110:[2,146],111:[2,146],112:[2,146],113:[2,146],114:[2,146],115:[2,146]},{13:[1,176],55:[1,175]},{9:[2,143],13:[2,143],30:[2,143],45:[2,143],48:[2,143],51:[2,143],55:[2,143],83:[2,143],85:[2,143],86:[2,143],88:[2,143],90:[2,143],91:[2,143],94:[2,143],102:[2,143],104:[2,143],105:[2,143],106:[2,143],107:[2,143],108:[2,143],109:[2,143],110:[2,143],111:[2,143],112:[2,143],113:[2,143],114:[2,143],115:[2,143]},{8:27,15:28,66:[1,8],68:177,69:21,70:178,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{8:75,11:[1,69],31:179,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:180,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:181,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:182,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:183,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:184,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:185,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:186,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:187,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:188,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:189,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:190,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:191,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:192,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{9:[2,141],13:[2,141],30:[2,141],45:[2,141],48:[2,141],51:[2,141],55:[2,141],83:[2,141],85:[2,141],86:[2,141],88:[2,141],90:[2,141],91:[2,141],94:[2,141],102:[2,141],104:[2,141],105:[2,141],106:[2,141],107:[2,141],108:[2,141],109:[2,141],110:[2,141],111:[2,141],112:[2,141],113:[2,141],114:[2,141],115:[2,141]},{9:[2,121],13:[2,121],30:[2,121],45:[2,121],48:[2,121],51:[2,121],55:[2,121],83:[2,121],85:[2,121],86:[2,121],88:[2,121],90:[2,121],91:[2,121],94:[2,121],102:[2,121],104:[2,121],105:[2,121],106:[2,121],107:[2,121],108:[2,121],109:[2,121],110:[2,121],111:[2,121],112:[2,121],113:[2,121],114:[2,121],115:[2,121]},{13:[1,193],30:[1,118],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{9:[2,123],13:[2,123],30:[2,123],45:[2,123],48:[2,123],51:[2,123],55:[2,123],83:[2,123],85:[2,123],86:[2,123],88:[2,123],90:[2,123],91:[2,123],94:[2,123],102:[2,123],104:[2,123],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[2,123],110:[1,115],111:[2,123],112:[2,123],113:[2,123],114:[2,123],115:[2,123]},{9:[2,124],13:[2,124],30:[2,124],45:[2,124],48:[2,124],51:[2,124],55:[2,124],83:[2,124],85:[2,124],86:[2,124],88:[2,124],90:[2,124],91:[2,124],94:[2,124],102:[2,124],104:[2,124],105:[2,124],106:[2,124],107:[2,124],108:[2,124],109:[2,124],110:[2,124],111:[2,124],112:[2,124],113:[2,124],114:[2,124],115:[2,124]},{9:[2,139],13:[2,139],30:[2,139],45:[2,139],48:[2,139],51:[2,139],55:[2,139],83:[2,139],85:[2,139],86:[2,139],88:[2,139],90:[2,139],91:[2,139],94:[2,139],102:[2,139],104:[2,139],105:[2,139],106:[2,139],107:[2,139],108:[2,139],109:[2,139],110:[2,139],111:[2,139],112:[2,139],113:[2,139],114:[2,139],115:[2,139]},{9:[2,140],13:[2,140],30:[2,140],45:[2,140],48:[2,140],51:[2,140],55:[2,140],83:[2,140],85:[2,140],86:[2,140],88:[2,140],90:[2,140],91:[2,140],94:[2,140],102:[2,140],104:[2,140],105:[2,140],106:[2,140],107:[2,140],108:[2,140],109:[2,140],110:[2,140],111:[2,140],112:[2,140],113:[2,140],114:[2,140],115:[2,140]},{8:75,11:[1,69],31:194,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:27,15:28,66:[1,8],69:195,70:196,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{8:203,44:[1,154],53:202,56:201,58:152,59:153,93:197,95:198,96:199,97:200,102:[1,155],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:204,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:27,15:28,66:[1,8],68:100,69:21,70:22,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],83:[1,205],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{9:[2,18]},{9:[2,20],30:[1,118],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{30:[1,206]},{9:[2,25],13:[2,25],30:[2,25],51:[2,25]},{9:[2,26],13:[2,26],30:[2,26],51:[2,26]},{9:[2,27],13:[2,27],30:[2,27],51:[2,27]},{9:[2,28],13:[2,28],30:[2,28],51:[2,28]},{9:[2,29],13:[2,29],30:[2,29],51:[2,29]},{9:[2,30],13:[2,30],30:[2,30],51:[2,30]},{9:[2,31],13:[2,31],30:[2,31],51:[2,31]},{9:[2,37],13:[2,37],30:[2,37],45:[2,37],51:[2,37],55:[2,37]},{9:[2,38],13:[2,38],30:[2,38],45:[2,38],51:[2,38],55:[2,38],57:[1,207]},{9:[2,39],13:[2,39],30:[2,39],45:[2,39],51:[2,39],55:[2,39]},{9:[2,32],13:[2,32],30:[2,32],43:[1,208],51:[2,32]},{43:[1,209]},{8:48,12:212,50:210,60:211,116:[1,15]},{54:213,116:[1,215],118:214},{57:[1,216]},{9:[2,47],13:[2,47],30:[2,47],32:[2,47],45:[2,47],51:[2,47],55:[2,47],57:[2,47]},{9:[2,48],13:[2,48],30:[2,48],32:[2,48],45:[2,48],51:[2,48],55:[2,48],57:[2,48]},{9:[2,150],13:[2,150],30:[2,150],32:[2,150],45:[2,150],51:[2,150],55:[2,150],57:[2,150]},{44:[1,217]},{9:[2,22]},{9:[2,24]},{9:[2,52]},{9:[2,54]},{9:[2,147],13:[2,147],32:[2,147],55:[2,147]},{5:218,14:5,15:6,18:7,19:[1,9],21:[1,10],23:[1,11],25:[1,12],27:[1,13],63:[1,219],66:[1,8]},{9:[2,56]},{9:[2,58]},{9:[1,221],13:[1,220]},{9:[2,66],32:[2,66]},{9:[2,68],13:[2,68]},{32:[1,222],55:[1,87]},{8:48,12:223,116:[1,15]},{8:145,11:[1,150],33:224,35:[1,137],36:[1,138],37:[1,139],38:[1,140],39:[1,141],40:142,41:143,42:[1,147],44:[1,154],46:[1,148],49:[1,149],52:144,53:146,56:151,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{9:[1,225]},{17:[2,8],19:[2,8],21:[2,8],23:[2,8],25:[2,8],27:[2,8],66:[2,8]},{9:[1,226],55:[1,87]},{9:[1,227]},{6:[2,145],9:[2,145],11:[2,145],13:[2,145],30:[2,145],43:[2,145],45:[2,145],48:[2,145],51:[2,145],55:[2,145],72:[2,145],83:[2,145],85:[2,145],86:[2,145],88:[2,145],90:[2,145],91:[2,145],94:[2,145],102:[2,145],104:[2,145],105:[2,145],106:[2,145],107:[2,145],108:[2,145],109:[2,145],110:[2,145],111:[2,145],112:[2,145],113:[2,145],114:[2,145],115:[2,145]},{8:75,11:[1,69],31:228,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{9:[2,142],13:[2,142],30:[2,142],45:[2,142],48:[2,142],51:[2,142],55:[2,142],83:[2,142],85:[2,142],86:[2,142],88:[2,142],90:[2,142],91:[2,142],94:[2,142],102:[2,142],104:[2,142],105:[2,142],106:[2,142],107:[2,142],108:[2,142],109:[2,142],110:[2,142],111:[2,142],112:[2,142],113:[2,142],114:[2,142],115:[2,142]},{9:[2,93],51:[2,93],83:[2,93],94:[2,93]},{9:[2,77],51:[2,77],83:[2,77],86:[1,229],94:[2,77]},{9:[2,125],13:[2,125],30:[2,125],45:[2,125],48:[2,125],51:[2,125],55:[2,125],83:[2,125],85:[2,125],86:[2,125],88:[2,125],90:[2,125],91:[2,125],94:[2,125],102:[2,125],104:[2,125],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[2,125],110:[1,115],111:[2,125],112:[2,125],113:[2,125],114:[2,125],115:[2,125]},{9:[2,126],13:[2,126],30:[2,126],45:[2,126],48:[2,126],51:[2,126],55:[2,126],83:[2,126],85:[2,126],86:[2,126],88:[2,126],90:[2,126],91:[2,126],94:[2,126],102:[2,126],104:[2,126],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[2,126],110:[1,115],111:[2,126],112:[2,126],113:[2,126],114:[2,126],115:[2,126]},{9:[2,127],13:[2,127],30:[2,127],45:[2,127],48:[2,127],51:[2,127],55:[2,127],83:[2,127],85:[2,127],86:[2,127],88:[2,127],90:[2,127],91:[2,127],94:[2,127],102:[2,127],104:[2,127],105:[2,127],106:[2,127],107:[2,127],108:[2,127],109:[2,127],110:[2,127],111:[2,127],112:[2,127],113:[2,127],114:[2,127],115:[2,127]},{9:[2,128],13:[2,128],30:[2,128],45:[2,128],48:[2,128],51:[2,128],55:[2,128],83:[2,128],85:[2,128],86:[2,128],88:[2,128],90:[2,128],91:[2,128],94:[2,128],102:[2,128],104:[2,128],105:[2,128],106:[2,128],107:[2,128],108:[2,128],109:[2,128],110:[2,128],111:[2,128],112:[2,128],113:[2,128],114:[2,128],115:[2,128]},{9:[2,129],13:[2,129],30:[2,129],45:[2,129],48:[2,129],51:[2,129],55:[2,129],83:[2,129],85:[2,129],86:[2,129],88:[2,129],90:[2,129],91:[2,129],94:[2,129],102:[2,129],104:[2,129],105:[2,129],106:[2,129],107:[2,129],108:[2,129],109:[2,129],110:[2,129],111:[2,129],112:[2,129],113:[2,129],114:[2,129],115:[2,129]},{9:[2,130],13:[2,130],30:[2,130],45:[2,130],48:[2,130],51:[2,130],55:[2,130],83:[2,130],85:[2,130],86:[2,130],88:[2,130],90:[2,130],91:[2,130],94:[2,130],102:[2,130],104:[2,130],105:[2,130],106:[2,130],107:[2,130],108:[2,130],109:[2,130],110:[2,130],111:[2,130],112:[2,130],113:[2,130],114:[2,130],115:[2,130]},{9:[2,131],13:[2,131],30:[2,131],45:[2,131],48:[2,131],51:[2,131],55:[2,131],83:[2,131],85:[2,131],86:[2,131],88:[2,131],90:[2,131],91:[2,131],94:[2,131],102:[2,131],104:[2,131],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[2,131],110:[1,115],111:[2,131],112:[2,131],113:[2,131],114:[2,131],115:[2,131]},{9:[2,132],13:[2,132],30:[2,132],45:[2,132],48:[2,132],51:[2,132],55:[2,132],83:[2,132],85:[2,132],86:[2,132],88:[2,132],90:[2,132],91:[2,132],94:[2,132],102:[2,132],104:[2,132],105:[2,132],106:[2,132],107:[2,132],108:[2,132],109:[2,132],110:[2,132],111:[2,132],112:[2,132],113:[2,132],114:[2,132],115:[2,132]},{9:[2,133],13:[2,133],30:[2,133],45:[2,133],48:[2,133],51:[2,133],55:[2,133],83:[2,133],85:[2,133],86:[2,133],88:[2,133],90:[2,133],91:[2,133],94:[2,133],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[2,133],112:[2,133],113:[2,133],114:[2,133],115:[2,133]},{9:[2,134],13:[2,134],30:[2,134],45:[2,134],48:[2,134],51:[2,134],55:[2,134],83:[2,134],85:[2,134],86:[2,134],88:[2,134],90:[2,134],91:[2,134],94:[2,134],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[2,134],112:[2,134],113:[2,134],114:[2,134],115:[2,134]},{9:[2,135],13:[2,135],30:[2,135],45:[2,135],48:[2,135],51:[2,135],55:[2,135],83:[2,135],85:[2,135],86:[2,135],88:[2,135],90:[2,135],91:[2,135],94:[2,135],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[2,135],112:[2,135],113:[2,135],114:[2,135],115:[2,135]},{9:[2,136],13:[2,136],30:[2,136],45:[2,136],48:[2,136],51:[2,136],55:[2,136],83:[2,136],85:[2,136],86:[2,136],88:[2,136],90:[2,136],91:[2,136],94:[2,136],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[2,136],112:[2,136],113:[2,136],114:[2,136],115:[2,136]},{9:[2,137],13:[2,137],30:[2,137],45:[2,137],48:[2,137],51:[2,137],55:[2,137],83:[2,137],85:[2,137],86:[2,137],88:[2,137],90:[2,137],91:[2,137],94:[2,137],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[2,137],112:[2,137],113:[2,137],114:[2,137],115:[2,137]},{9:[2,138],13:[2,138],30:[2,138],45:[2,138],48:[2,138],51:[2,138],55:[2,138],83:[2,138],85:[2,138],86:[2,138],88:[2,138],90:[2,138],91:[2,138],94:[2,138],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[2,138],112:[2,138],113:[2,138],114:[2,138],115:[2,138]},{9:[2,122],13:[2,122],30:[2,122],45:[2,122],48:[2,122],51:[2,122],55:[2,122],83:[2,122],85:[2,122],86:[2,122],88:[2,122],90:[2,122],91:[2,122],94:[2,122],102:[2,122],104:[2,122],105:[2,122],106:[2,122],107:[2,122],108:[2,122],109:[2,122],110:[2,122],111:[2,122],112:[2,122],113:[2,122],114:[2,122],115:[2,122]},{30:[1,118],90:[1,230],91:[1,231],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{9:[2,96],51:[2,96],83:[2,96],94:[2,96]},{9:[2,95],51:[2,95],83:[2,95],86:[2,95],94:[2,95]},{9:[1,233],51:[1,232],94:[1,234]},{9:[2,108],51:[2,108],94:[2,108]},{32:[1,235],55:[1,236]},{32:[2,111],55:[2,111]},{32:[2,112],55:[2,112],57:[1,216]},{32:[2,113],55:[2,113]},{57:[1,207]},{9:[2,90],30:[1,118],51:[2,90],83:[2,90],86:[2,90],94:[2,90],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{8:75,11:[1,69],31:237,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:238,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:240,44:[1,154],56:239,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{44:[1,241]},{8:145,11:[1,150],40:243,44:[1,154],47:242,52:144,53:146,56:151,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{9:[1,245],51:[1,244]},{9:[2,50],51:[2,50]},{32:[1,246],55:[1,87]},{13:[1,247],55:[1,248]},{13:[2,154],55:[2,154]},{13:[2,155],55:[2,155]},{8:250,44:[1,154],56:249,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{9:[2,151],13:[2,151],30:[2,151],32:[2,151],45:[2,151],51:[2,151],55:[2,151],57:[2,151]},{9:[2,55]},{9:[2,57]},{9:[2,65],32:[2,65]},{8:48,12:167,23:[1,168],65:251,116:[1,15]},{8:145,11:[1,150],33:252,35:[1,137],36:[1,138],37:[1,139],38:[1,140],39:[1,141],40:142,41:143,42:[1,147],44:[1,154],46:[1,148],49:[1,149],52:144,53:146,56:151,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{32:[1,253],55:[1,87]},{9:[1,254]},{5:255,14:5,15:6,18:7,19:[1,9],21:[1,10],23:[1,11],25:[1,12],27:[1,13],63:[1,256],66:[1,8]},{17:[2,10],19:[2,10],21:[2,10],23:[2,10],25:[2,10],27:[2,10],66:[2,10]},{10:257,16:96,17:[1,97],19:[2,5],21:[2,5],23:[2,5],25:[2,5],27:[2,5],66:[2,5]},{13:[2,114],30:[1,118],45:[2,114],55:[2,114],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{8:27,15:28,66:[1,8],69:258,70:259,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{8:75,11:[1,69],31:260,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{8:75,11:[1,69],31:261,35:[1,72],38:[1,73],44:[1,63],59:66,71:67,99:[1,64],100:[1,65],101:[1,68],102:[1,70],103:[1,71],116:[1,15],117:[1,74]},{9:[2,101],51:[2,101],83:[2,101],86:[2,101],94:[2,101]},{8:203,44:[1,154],51:[1,262],53:202,56:201,58:152,59:153,94:[1,263],95:264,96:199,97:200,102:[1,155],116:[1,15],117:[1,74]},{8:27,15:28,66:[1,8],68:265,69:21,70:22,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{8:27,15:28,66:[1,8],68:266,69:21,70:22,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{8:203,44:[1,154],53:202,56:201,58:152,59:153,97:267,102:[1,155],116:[1,15],117:[1,74]},{9:[2,91],30:[1,118],51:[2,91],83:[2,91],86:[2,91],94:[2,91],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{9:[2,21],30:[1,118],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{9:[2,44],13:[2,44],30:[2,44],32:[2,44],45:[2,44],51:[2,44],55:[2,44]},{9:[2,46],13:[2,46],30:[2,46],32:[2,46],45:[2,46],51:[2,46],55:[2,46]},{45:[1,268]},{45:[1,269],55:[1,270]},{45:[2,42],55:[2,42]},{9:[2,35],13:[2,35],30:[2,35],51:[2,35]},{8:48,12:212,51:[1,271],60:272,116:[1,15]},{8:145,11:[1,150],33:273,35:[1,137],36:[1,138],37:[1,139],38:[1,140],39:[1,141],40:142,41:143,42:[1,147],44:[1,154],46:[1,148],49:[1,149],52:144,53:146,56:151,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{9:[2,40],13:[2,40],30:[2,40],45:[2,40],51:[2,40],55:[2,40]},{116:[1,215],118:274},{9:[2,43],13:[2,43],30:[2,43],32:[2,43],45:[2,43],51:[2,43],55:[2,43]},{9:[2,45],13:[2,45],30:[2,45],32:[2,45],45:[2,45],51:[2,45],55:[2,45]},{9:[2,67],13:[2,67]},{9:[2,69],13:[2,69]},{8:145,11:[1,150],33:275,35:[1,137],36:[1,138],37:[1,139],38:[1,140],39:[1,141],40:142,41:143,42:[1,147],44:[1,154],46:[1,148],49:[1,149],52:144,53:146,56:151,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{5:276,14:5,15:6,18:7,19:[1,9],21:[1,10],23:[1,11],25:[1,12],27:[1,13],63:[1,277],66:[1,8]},{9:[2,61]},{9:[2,63]},{16:171,17:[1,97],19:[2,4],21:[2,4],23:[2,4],25:[2,4],27:[2,4],66:[2,4]},{9:[2,94],51:[2,94],83:[2,94],94:[2,94]},{9:[2,92],51:[2,92],83:[2,92],86:[2,92],94:[2,92]},{30:[1,118],88:[1,278],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{30:[1,118],88:[1,279],102:[1,109],104:[1,108],105:[1,110],106:[1,111],107:[1,112],108:[1,113],109:[1,114],110:[1,115],111:[1,116],112:[1,117],113:[1,119],114:[1,120],115:[1,121]},{9:[2,102],51:[2,102],83:[2,102],86:[2,102],94:[2,102]},{8:27,15:28,66:[1,8],68:280,69:21,70:22,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{9:[2,107],51:[2,107],94:[2,107]},{9:[1,282],51:[1,281]},{9:[2,109],51:[2,109],94:[2,109]},{32:[2,110],55:[2,110]},{9:[2,33],13:[2,33],30:[2,33],51:[2,33]},{48:[1,283]},{8:145,11:[1,150],40:284,44:[1,154],52:144,53:146,56:151,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{9:[2,36],13:[2,36],30:[2,36],51:[2,36]},{9:[2,49],51:[2,49]},{9:[2,51],51:[2,51]},{13:[2,153],55:[2,153]},{9:[2,70],13:[2,70]},{9:[2,60]},{9:[2,62]},{8:27,15:28,66:[1,8],69:285,70:286,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{8:27,15:28,66:[1,8],69:287,70:288,71:26,74:29,75:30,76:31,77:32,78:33,79:23,80:24,81:25,82:[1,38],84:[1,34],87:[1,36],89:[1,35],92:[1,37],116:[1,15]},{9:[1,290],51:[1,289]},{9:[2,103],51:[2,103],83:[2,103],86:[2,103],94:[2,103]},{51:[1,291]},{8:145,11:[1,150],33:292,35:[1,137],36:[1,138],37:[1,139],38:[1,140],39:[1,141],40:142,41:143,42:[1,147],44:[1,154],46:[1,148],49:[1,149],52:144,53:146,56:151,58:152,59:153,102:[1,155],116:[1,15],117:[1,74]},{45:[2,41],55:[2,41]},{9:[2,99],51:[2,99],83:[2,99],94:[2,99]},{9:[2,97],51:[2,97],83:[2,97],86:[2,97],94:[2,97]},{9:[2,100],51:[2,100],83:[2,100],94:[2,100]},{9:[2,98],51:[2,98],83:[2,98],86:[2,98],94:[2,98]},{9:[2,104],51:[2,104],83:[2,104],86:[2,104],94:[2,104]},{51:[1,293]},{9:[2,105],51:[2,105],83:[2,105],86:[2,105],94:[2,105]},{9:[2,34],13:[2,34],30:[2,34],51:[2,34]},{9:[2,106],51:[2,106],83:[2,106],86:[2,106],94:[2,106]}],
        defaultActions: {16:[2,1],40:[2,19],43:[2,23],46:[2,53],134:[2,18],156:[2,22],157:[2,24],158:[2,52],159:[2,54],162:[2,56],163:[2,58],218:[2,55],219:[2,57],255:[2,61],256:[2,63],276:[2,60],277:[2,62]},
        parseError: function parseError(str, hash) {
            throw new Error(str);
        },
        parse: function parse(input) {
            var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == "undefined")
                this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            if (typeof this.yy.parseError === "function")
                this.parseError = this.yy.parseError;
            function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
            }
            function lex() {
                var token;
                token = self.lexer.lex() || 1;
                if (typeof token !== "number") {
                    token = self.symbols_[token] || token;
                }
                return token;
            }
            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
            while (true) {
                state = stack[stack.length - 1];
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == "undefined") {
                        symbol = lex();
                    }
                    action = table[state] && table[state][symbol];
                }
                if (typeof action === "undefined" || !action.length || !action[0]) {
                    var errStr = "";
                    if (!recovering) {
                        expected = [];
                        for (p in table[state])
                            if (this.terminals_[p] && p > 2) {
                                expected.push("'" + this.terminals_[p] + "'");
                            }
                        if (this.lexer.showPosition) {
                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                        } else {
                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1?"end of input":"'" + (this.terminals_[symbol] || symbol) + "'");
                        }
                        this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
                    }
                }
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                }
                switch (action[0]) {
                    case 1:
                        stack.push(symbol);
                        vstack.push(this.lexer.yytext);
                        lstack.push(this.lexer.yylloc);
                        stack.push(action[1]);
                        symbol = null;
                        if (!preErrorSymbol) {
                            yyleng = this.lexer.yyleng;
                            yytext = this.lexer.yytext;
                            yylineno = this.lexer.yylineno;
                            yyloc = this.lexer.yylloc;
                            if (recovering > 0)
                                recovering--;
                        } else {
                            symbol = preErrorSymbol;
                            preErrorSymbol = null;
                        }
                        break;
                    case 2:
                        len = this.productions_[action[1]][1];
                        yyval.$ = vstack[vstack.length - len];
                        yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
                        if (ranges) {
                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                        }
                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                        if (typeof r !== "undefined") {
                            return r;
                        }
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len);
                        }
                        stack.push(this.productions_[action[1]][0]);
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;
                    case 3:
                        return true;
                }
            }
            return true;
        }
    };

    function isNode() {
        return typeof process === 'object' && typeof require === 'function';
    }

    function inspect(obj) {
        if (isNode()) {
            var util = require("util");
            console.warn(util.inspect(obj,false,20));
        } else {
            console.warn(JSON.stringify(obj,null,4))
        }
    }
    /* generated by jison-lex 0.1.0 */
    var lexer = (function(){
        var lexer = {
            EOF:1,
            parseError:function parseError(str, hash) {
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },
            setInput:function (input) {
                this._input = input;
                this._more = this._less = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = '';
                this.conditionStack = ['INITIAL'];
                this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
                if (this.options.ranges) this.yylloc.range = [0,0];
                this.offset = 0;
                return this;
            },
            input:function () {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++;
                } else {
                    this.yylloc.last_column++;
                }
                if (this.options.ranges) this.yylloc.range[1]++;

                this._input = this._input.slice(1);
                return ch;
            },
            unput:function (ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);

                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
                //this.yyleng -= len;
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length-1);
                this.matched = this.matched.substr(0, this.matched.length-1);

                if (lines.length-1) this.yylineno -= lines.length-1;
                var r = this.yylloc.range;

                this.yylloc = {first_line: this.yylloc.first_line,
                    last_line: this.yylineno+1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ?
                        (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
                        this.yylloc.first_column - len
                };

                if (this.options.ranges) {
                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                }
                return this;
            },
            more:function () {
                this._more = true;
                return this;
            },
            less:function (n) {
                this.unput(this.match.slice(n));
            },
            pastInput:function () {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput:function () {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20-next.length);
                }
                return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
            },
            showPosition:function () {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c+"^";
            },
            next:function () {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) this.done = true;

                var token,
                    match,
                    tempMatch,
                    index,
                    col,
                    lines;
                if (!this._more) {
                    this.yytext = '';
                    this.match = '';
                }
                var rules = this._currentRules();
                for (var i=0;i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (!this.options.flex) break;
                    }
                }
                if (match) {
                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) this.yylineno += lines.length;
                    this.yylloc = {first_line: this.yylloc.last_line,
                        last_line: this.yylineno+1,
                        first_column: this.yylloc.last_column,
                        last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
                    if (this.done && this._input) this.done = false;
                    if (token) return token;
                    else return;
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                        {text: "", token: null, line: this.yylineno});
                }
            },
            lex:function lex() {
                var r = this.next();
                if (typeof r !== 'undefined') {
                    return r;
                } else {
                    return this.lex();
                }
            },
            begin:function begin(condition) {
                this.conditionStack.push(condition);
            },
            popState:function popState() {
                return this.conditionStack.pop();
            },
            _currentRules:function _currentRules() {
                return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
            },
            topState:function () {
                return this.conditionStack[this.conditionStack.length-2];
            },
            pushState:function begin(condition) {
                this.begin(condition);
            },
            options: {"case-insensitive":true},
            performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {

                var YYSTATE=YY_START;
                switch($avoiding_name_collisions) {
                    case 0:this.begin('comment');
                        break;
                    case 1:/* ignore comment contents up to "*" */
                        break;
                    case 2:/* ignore '*" in comment that is not before ")" */
                        break;
                    case 3:this.begin('INITIAL');
                        break;
                    case 4:/* skip comment */
                        break;
                    case 5:return "REAL_LITERAL";
                        break;
                    case 6:return "INTEGER_LITERAL";
                        break;
                    case 7:return "STRING_LITERAL";
                        break;
                    case 8:return "CHARACTER_LITERAL";
                        break;
                    case 9:return "ASSIGN";  /* Needs to be before COLON and EQ */
                        break;
                    case 10:return "COLON";
                        break;
                    case 11:return "SEMI";
                        break;
                    case 12:return "COMMA";
                        break;
                    case 13:return "DOTDOT";
                        break;
                    case 14:return "DOT";
                        break;
                    case 15:return "LPAREN";
                        break;
                    case 16:return "RPAREN";
                        break;
                    case 17:return "LBRACK";
                        break;
                    case 18:return "RBRACK";
                        break;
                    case 19:return "LCURLY";
                        break;
                    case 20:return "RCURLY";
                        break;
                    case 21:return "CARET";
                        break;
                    case 22:return "LEQ";
                        break;
                    case 23:return "GEQ";
                        break;
                    case 24:return "NEQ";
                        break;
                    case 25:return "PLUS";
                        break;
                    case 26:return "MINUS";
                        break;
                    case 27:return "STAR";
                        break;
                    case 28:return "SLASH";
                        break;
                    case 29:return "LT";
                        break;
                    case 30:return "GT";
                        break;
                    case 31:return "EQ";
                        break;
                    case 32:return "AND";
                        break;
                    case 33:return "DIV";
                        break;
                    case 34:return "IN";
                        break;
                    case 35:return "MOD";
                        break;
                    case 36:return "NOT";
                        break;
                    case 37:return "OR";
                        break;
                    case 38:return "SHL";
                        break;
                    case 39:return "SHR";
                        break;
                    case 40:return "XOR";
                        break;
                    case 41:return "ABSOLUTE";
                        break;
                    case 42:return "ARRAY";
                        break;
                    case 43:return "BEGIN";
                        break;
                    case 44:return "CASE";
                        break;
                    case 45:return "CONST";
                        break;
                    case 46:return "DO";
                        break;
                    case 47:return "DOWNTO";
                        break;
                    case 48:return "ELSE";
                        break;
                    case 49:return "OTHERWISE";
                        break;
                    case 50:return "END";
                        break;
                    case 51:return "EXTERNAL";
                        break;
                    case 52:return "FILE";
                        break;
                    case 53:return "FOR";
                        break;
                    case 54:return "FORWARD";
                        break;
                    case 55:return "FUNCTION";
                        break;
                    case 56:return "GOTO";
                        break;
                    case 57:return "IF";
                        break;
                    case 58:return "INLINE";
                        break;
                    case 59:return "LABEL";
                        break;
                    case 60:return "OF";
                        break;
                    case 61:return "PACKED";
                        break;
                    case 62:return "PROCEDURE";
                        break;
                    case 63:return "PROGRAM";
                        break;
                    case 64:return "RECORD";
                        break;
                    case 65:return "REPEAT";
                        break;
                    case 66:return "SET";
                        break;
                    case 67:return "THEN";
                        break;
                    case 68:return "TO";
                        break;
                    case 69:return "TYPE";
                        break;
                    case 70:return "UNTIL";
                        break;
                    case 71:return "USES";
                        break;
                    case 72:return "VAR";
                        break;
                    case 73:return "WHILE";
                        break;
                    case 74:return "WITH";
                        break;
                    case 75:return "INTEGER";
                        break;
                    case 76:return "REAL";
                        break;
                    case 77:return "STRING";
                        break;
                    case 78:return "BOOLEAN";
                        break;
                    case 79:return "CHAR";
                        break;
                    case 80:return "BYTE";
                        break;
                    case 81:return "ID";
                        break;
                    case 82:/* skip whitespace */
                        break;
                    case 83:return 'EOF'
                        break;
                    case 84:return 'INVALID'
                        break;
                }
            },
            rules: [/^(?:\(\*)/i,/^(?:[^*][^*]*)/i,/^(?:\*+[^)])/i,/^(?:\*\))/i,/^(?:\{[^}]*\})/i,/^(?:([0-9]+\.[0-9]+))/i,/^(?:([0-9]+))/i,/^(?:('(?:[^']+|'')(?:[^']+|'')+'))/i,/^(?:(#[0-9]+|'([^']+|'')'))/i,/^(?::=)/i,/^(?::)/i,/^(?:;)/i,/^(?:,)/i,/^(?:\.\.)/i,/^(?:\.)/i,/^(?:\()/i,/^(?:\))/i,/^(?:\[)/i,/^(?:\])/i,/^(?:\{)/i,/^(?:\})/i,/^(?:\^)/i,/^(?:<=)/i,/^(?:>=)/i,/^(?:<>)/i,/^(?:\+)/i,/^(?:-)/i,/^(?:\*)/i,/^(?:\/)/i,/^(?:<)/i,/^(?:>)/i,/^(?:=)/i,/^(?:AND\b)/i,/^(?:DIV\b)/i,/^(?:IN\b)/i,/^(?:MOD\b)/i,/^(?:NOT\b)/i,/^(?:OR\b)/i,/^(?:SHL\b)/i,/^(?:SHR\b)/i,/^(?:XOR\b)/i,/^(?:ABSOLUTE\b)/i,/^(?:ARRAY\b)/i,/^(?:BEGIN\b)/i,/^(?:CASE\b)/i,/^(?:CONST\b)/i,/^(?:DO\b)/i,/^(?:DOWNTO\b)/i,/^(?:ELSE\b)/i,/^(?:OTHERWISE\b)/i,/^(?:END\b)/i,/^(?:EXTERNAL\b)/i,/^(?:FILE\b)/i,/^(?:FOR\b)/i,/^(?:FORWARD\b)/i,/^(?:FUNCTION\b)/i,/^(?:GOTO\b)/i,/^(?:IF\b)/i,/^(?:INLINE\b)/i,/^(?:LABEL\b)/i,/^(?:OF\b)/i,/^(?:PACKED\b)/i,/^(?:PROCEDURE\b)/i,/^(?:PROGRAM\b)/i,/^(?:RECORD\b)/i,/^(?:REPEAT\b)/i,/^(?:SET\b)/i,/^(?:THEN\b)/i,/^(?:TO\b)/i,/^(?:TYPE\b)/i,/^(?:UNTIL\b)/i,/^(?:USES\b)/i,/^(?:VAR\b)/i,/^(?:WHILE\b)/i,/^(?:WITH\b)/i,/^(?:INTEGER\b)/i,/^(?:REAL\b)/i,/^(?:STRING\b)/i,/^(?:BOOLEAN\b)/i,/^(?:CHAR\b)/i,/^(?:BYTE\b)/i,/^(?:([A-Za-z_][A-Za-z0-9_]*))/i,/^(?:(\s+))/i,/^(?:$)/i,/^(?:.)/i],
            conditions: {"comment":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84],"inclusive":true},"INITIAL":{"rules":[0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84],"inclusive":true}}
        };
        return lexer;
    })();
    parser.lexer = lexer;
    function Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;
    return new Parser;
})();
if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
    exports.parser = parse;
    exports.Parser = parse.Parser;
    exports.parse = function () { return parse.parse.apply(parse, arguments); };
    exports.main = function commonjsMain(args) {
        if (!args[1]) {
            console.log('Usage: '+args[0]+' FILE');
            process.exit(1);
        }
        var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
        return exports.parser.parse(source);
    };
    if (typeof module !== 'undefined' && require.main === module) {
        exports.main(process.argv.slice(1));
    }
}




function Convert2Bin(outstring, statstring, signBit, power, rounding)
{
    output = new String()                 //Output

    var binexpnt, index1, index2, cnst, bias, lastbit, rounded, index3, binexpnt2
    var moreBits

    cnst = 2102   // 1 (carry bit) + 1023 + 1 + 1022 + 53 + 2 (round bits)
    bias = 1024

    //init
    for (index1 = 0; index1 < this.Size; index1++)  this.Result[index1] = 0

    with (Math)
    {
        //sign bit
        this.Result[0] = signBit

        //obtain exponent value
        index1 = 0

        if (this.Size == 32) index2 = 9
        else index2 = 12

        if (rounding && (statstring == "normal"))
        {
            //find most significant bit of significand
            while ((index1 < cnst) && (this.BinVal[index1] != 1)) index1++

            binexpnt = bias - index1

            //regular normalized numbers
            if (binexpnt >= this.MinExp)
            {
                //the value is shifted until the most
                index1++    //significant 1 is to the left of the binary
                //point and that bit is implicit in the encoding
            }//if normalized numbers

            //support for zero and denormalized numbers
            //exponent underflow for this precision
            else
            {
                binexpnt = this.MinExp - 1
                index1 = bias - binexpnt
            }//if zero or denormalized (else section)


            //use round to nearest value mode

            //compute least significant (low-order) bit of significand
            lastbit = this.Size - 1 - index2 + index1

            //the bits folllowing the low-order bit have a value of (at least) 1/2
            if (this.BinVal[lastbit + 1] == 1)
            {
                rounded = 0

                //odd low-order bit
                if (this.BinVal[lastbit] == 1)
                {
                    //exactly 1/2 the way between odd and even rounds up to the even,
                    //so the rest of the bits don't need to be checked to see if the value
                    //is more than 1/2 since the round up to the even number will occur
                    //anyway due to the 1/2
                    rounded = 1
                }//if odd low-order bit

                //even low-order bit
                else  //this.BinVal[lastbit] == 0
                {
                    //exactly 1/2 the way between even and odd rounds down to the even,
                    //so the rest of the bits need to be checked to see if the value
                    //is more than 1/2 in order to round up to the odd number
                    index3 = lastbit + 2
                    while ((rounded == 0) && (index3 < cnst))
                    {
                        rounded = this.BinVal[index3]
                        index3++
                    }//while checking for more than 1/2

                }//if even low-order bit (else section)

                //do rounding "additions"
                index3 = lastbit
                while ((rounded == 1) && (index3 >= 0))
                {
                    // 0 + 1 -> 1 result with 0 carry
                    if (this.BinVal[index3] == 0)
                    {
                        // 1 result
                        this.BinVal[index3] = 1

                        // 0 carry
                        rounded = 0

                    }//if bit is a 0

                    // 1 + 1 -> 0 result with 1 carry
                    else  //this.BinVal[index3] == 1
                    {
                        // 0 result
                        this.BinVal[index3] = 0

                        // 1 carry
//          rounded = 1
                    }//if bit is a 1 (else section)

                    index3--
                }//while "adding" carries from right to left in bits

            }//if at least 1/2

            //obtain exponent value
            index1 = index1 - 2
            if (index1 < 0) index1 = 0

        }//if rounding

        //find most significant bit of significand
        while ((index1 < cnst) && (this.BinVal[index1] != 1)) index1++

        binexpnt2 = bias - index1

        if (statstring == "normal")
        {
            binexpnt = binexpnt2

            //regular normalized numbers
            if ((binexpnt >= this.MinExp) && (binexpnt <= this.MaxExp))
            {
                //the value is shifted until the most
                index1++                //significant 1 is to the left of the binary
                                        //point and that bit is implicit in the encoding
            }//if normalized numbers

            //support for zero and denormalized numbers
            //exponent underflow for this precision
            else if (binexpnt < this.MinExp)
            {
                if (binexpnt2 == bias - cnst)
                //value is truely zero
                    this.StatCond = "normal"
                else if (binexpnt2 < this.MinUnnormExp)
                    this.StatCond = "underflow"
                else
                    this.StatCond = "denormalized"

                binexpnt = this.MinExp - 1
                index1 = bias - binexpnt
            }//if zero or denormalized (else if section)
        }

        else //already special values
        {
            binexpnt = power
            index1 = bias - binexpnt

            if (binexpnt > this.MaxExp)
                binexpnt = this.MaxExp + 1

            else if (binexpnt < this.MinExp)
                binexpnt = this.MinExp - 1

        }//if already special (else section)

        //copy the result
        while ((index2 < this.Size) && (index1 < cnst))
        {
            this.Result[index2] = this.BinVal[index1]
            index2++
            index1++
        }//while

        //max exponent for this precision
        if ((binexpnt > this.MaxExp) || (statstring != "normal"))
        {
            //overflow of this precision, set infinity
            if (statstring == "normal")
            {
                binexpnt = this.MaxExp + 1
                this.StatCond = "overflow"
                this.DispStr = "Infinity"

                if (this.Result[0] == 1)
                    this.DispStr = "-" + this.DispStr

                if (this.Size == 32) index2 = 9
                else index2 = 12

                //zero the significand
                while (index2 < this.Size)
                {
                    this.Result[index2] = 0
                    index2++
                }//while

            }//if overflowed

            else //already special values
            {
                this.StatCond = statstring
                this.DispStr = outstring
            }//if already special (else section)

        }//if max exponent

        //convert exponent value to binary representation
        if (this.Size == 32) index1 = 8
        else index1 = 11
        this.BinaryPower = binexpnt
        binexpnt += this.ExpBias    //bias
        while ((binexpnt / 2) != 0)
        {
            this.Result[index1] = binexpnt % 2
            if (binexpnt % 2 == 0) binexpnt = binexpnt / 2
            else binexpnt = binexpnt / 2 - 0.5
            index1 -= 1
        }

        //output binary result
        output = ""
        for (index1 = 0; index1 < this.Size; index1++)
            output = output + this.Result[index1]
        return output

    }//with Math
}

function Dec2Bin(input)
{
    var value, intpart, decpart, binexpnt, index1, cnst, bias

    cnst = 2102   // 1 (carry bit) + 1023 + 1 + 1022 + 53 + 2 (round bits)
    bias = 1024

    //init
    for (index1 = 0; index1 < cnst; index1++)  this.BinVal[index1] = 0

    with (Math)
    {
        input = Canonical(input)

        //sign bit
        if (input.charAt(0) == "-")
            this.Result[0] = 1
        else
            this.Result[0] = 0

        //if value magnitude greater than 1.7976931348623157E+308, set infinity
        input = OvfCheck(input)

        if (input.indexOf("Infinity") != -1)
        {
            binexpnt = this.MaxExp + 1
            this.StatCond64 = "overflow"
            this.DispStr = input

        }//if greater than 1.7976931348623157E+308

        //Value magnitude is not greater than 1.7976931348623157E+308
        else
        {

            //if value magnitude less than 2.4703282292062328E-324, set "underflow".
            this.StatCond64 = UndfCheck(input)

            if (this.StatCond64 == "underflow")
            {
                binexpnt = this.MinExp - 1

            }//if less than 2.4703282292062328E-324

            //Value magnitude is not less than 2.4703282292062328E-324
            else
            {

                //convert 'input' from string to numeric
                input = input * 1.0

                //convert and seperate input to integer and decimal parts
                value = abs(input)
                intpart = floor(value)
                decpart = value - intpart

                //convert integer part
                index1 = bias
                while (((intpart / 2) != 0) && (index1 >= 0))
                {
                    this.BinVal[index1] = intpart % 2
                    if (intpart % 2 == 0) intpart = intpart / 2
                    else intpart = intpart / 2 - 0.5
                    index1 -= 1
                }

                //convert decimal part
                index1 = bias + 1
                while ((decpart > 0) && (index1 < cnst))
                {
                    decpart *= 2
                    if (decpart >= 1)
                    {this.BinVal[index1] = 1; decpart --; index1++}
                    else {this.BinVal[index1] = 0; index1++}
                }

                //obtain exponent value
                index1 = 0

                //find most significant bit of significand
                while ((index1 < cnst) && (this.BinVal[index1] != 1)) index1++

                binexpnt = bias - index1

                //support for zero and denormalized numbers
                //exponent underflow for this precision
                if (binexpnt < this.MinExp)
                {
                    binexpnt = this.MinExp - 1

                }//if zero or denormalized

            }//if not less than 2.4703282292062328E-324 (else section)

        }//if not greater than 1.7976931348623157E+308 (else section)

        //output exponent value
        this.BinaryPower = binexpnt

    }//with Math
}

function Canonical(input)
{
    output = new String()
    numerals = new String()
    expstr = new String()
    signstr = new String()
    expsignstr = new String()
    expstrtmp = new String()

    var locE, stop, expnum, locDPact, locDP, start, MSDfound, index, expdelta
    var expstart, expprecision

    numerals = "0123456789";

    expprecision = 5

    input = input.toUpperCase()

    locE = input.indexOf("E");
    if (locE != -1)
    {
        stop = locE
        expstr = input.substring(locE + 1, input.length)
        expnum = expstr * 1
    }
    else
    {
        stop = input.length
        expnum = 0
    }

    locDPact = input.indexOf(".");
    if (locDPact != -1)
        locDP = locDPact
    else
        locDP = stop

    start = 0
    if (input.charAt(start) == "-")
    {
        start++
        signstr = "-"
    }
    else if (input.charAt(start) == "+")
    {
        start++
        signstr = "+"
    }
    else
        signstr = "+"

    MSDfound = false
    while ((start < stop) && !MSDfound)
    {
        index = 1
        while (index < numerals.length)
        {
            if (input.charAt(start) == numerals.charAt(index))
            {
                MSDfound = true
                break
            }
            index++
        }
        start++
    }
    start--

    if (MSDfound)
    {
        expdelta = locDP - start
        if (expdelta > 0)
            expdelta = expdelta - 1

        expnum = expnum + expdelta
    }
    else  //No significant digits found, value is zero
        expnum = 0

    expstrtmp = "" + expnum

    expstart = 0
    if (expstrtmp.charAt(expstart) == "-")
    {
        expstart++
        expsignstr = "-"
    }
    else
        expsignstr = "+"

    expstr = "E" + expsignstr

    index = 0
    while (index < expprecision - expstrtmp.length + expstart)
    {
        expstr += "0"
        index++
    }

    expstr += expstrtmp.substring(expstart, expstrtmp.length)

    output = signstr

    if (locDPact == start + 1)
    {
        output += input.substring(start, stop)
    }
    else if (stop == start + 1)
    {
        output += input.substring(start, stop)
        output += "."
    }
    else if (locDPact < start)
    {
        output += input.substring(start, start + 1)
        output += "."
        output += input.substring(start + 1, stop)
    }
    else if (locDPact != -1)
    {
        output += input.substring(start, start + 1)
        output += "."
        output += input.substring(start + 1, locDPact)
        output += input.substring(locDPact + 1, stop)
    }
    else
    {
        output += input.substring(start, stop)
        output += "."
    }

    output += expstr

    return output;
}

function MostSigOrder(input)
{
    output = new String()
    expstr = new String()

    var expprecision, expbias, stop, expnum, index

    expprecision = 5
    expbias = 50000

    stop = input.indexOf("E");

    output = input.substring(stop + 1, input.length)
    expnum = output * 1
    expnum += expbias

    expstr = "" + expnum

    output = expstr

    index = 0
    while (index < expprecision - expstr.length)
    {
        output = "0" + output
        index++
    }

    output += input.substring(1, 2)
    output += input.substring(3, stop)

    return output;
}

function A_gt_B(A, B)
{
    numerals = new String()

    var greater, stop, index, Adigit, Bdigit

    numerals = "0123456789";

    greater = false

    if (A.length > B.length)
        stop = A.length
    else
        stop = B.length

    index = 0
    while (index < stop)
    {
        if (index < A.length)
            Adigit = numerals.indexOf(A.charAt(index))
        else
            Adigit = 0

        if (index < B.length)
            Bdigit = numerals.indexOf(B.charAt(index))
        else
            Bdigit = 0

        if (Adigit < Bdigit)
            break
        else if (Adigit > Bdigit)
        {
            greater = true
            break
        }

        index++
    }//end while

    return greater;
}

function OvfCheck(input)
{
    output = new String()

    //Is value magnitude greater than +1.7976931348623157E+00308
    if (A_gt_B(MostSigOrder(input), "5030817976931348623157"))
    {
        output = "Infinity"
        if (input.charAt(0) == "-")
            output = "-" + output
    }
    else
        output = input

    return output;
}

function UndfCheck(input)
{
    output = new String()

    //Is value magnitude less than +2.4703282292062328E-00324
    if (A_gt_B("4967624703282292062328", MostSigOrder(input)))
        output = "underflow"
    else
        output = "normal"

    return output;
}

function RemoveBlanks(input)
{
    output = new String()

    var start, stop

    start = 0
    while ((input.charAt(start) == " ") && (start < input.length))
        start++

    stop = input.length - 1
    while ((input.charAt(stop) == " ") && (stop >= 0))
        stop--

    output = input.substring(start, stop + 1)

    return output
}

function Convert2Hex()
{
    output = new String()
    numerals = new String()

    var temp, index, i

    numerals = "0123456789ABCDEF"

    with (Math)
    {
        //convert binary result to hex and output
        for (index = 0; index < this.Size; index +=4)
        {
            temp = 0
            for (i = 0; i < 4; i++)
                temp += pow(2, 3 - i)*this.Result[index + i]

            output = output + numerals.charAt(temp)
        }
    }
    return output
}

function numStrClipOff(input, precision)
{
    result = new String()
    numerals = new String()
    tempstr = new String()
    expstr = new String()
    signstr = new String()

    var locE, stop, expnum, locDP, start, MSD, MSDfound, index, expdelta, digits
    var number

    numerals = "0123456789";

    tempstr = input.toUpperCase()

    locE = tempstr.indexOf("E");
    if (locE != -1)
    {
        stop = locE
        expstr = input.substring(locE + 1, input.length)
        expnum = expstr * 1
    }
    else
    {
        stop = input.length
        expnum = 0
    }

    if (input.indexOf(".") == -1)
    {
        tempstr = input.substring(0, stop)
        tempstr += "."
        if (input.length != stop)
            tempstr += input.substring(locE, input.length)

        input = tempstr

        locE = locE + 1
        stop = stop + 1
    }

    locDP = input.indexOf(".");

    start = 0
    if (input.charAt(start) == "-")
    {
        start++
        signstr = "-"
    }
    else
        signstr = ""

    MSD = start
    MSDfound = false
    while ((MSD < stop) && !MSDfound)
    {
        index = 1
        while (index < numerals.length)
        {
            if (input.charAt(MSD) == numerals.charAt(index))
            {
                MSDfound = true
                break
            }
            index++
        }
        MSD++
    }
    MSD--

    if (MSDfound)
    {
        expdelta = locDP - MSD
        if (expdelta > 0)
            expdelta = expdelta - 1

        expnum = expnum + expdelta

        expstr = "e" + expnum
    }
    else  //No significant digits found, value is zero
        MSD = start

    digits = stop - MSD

    tempstr = input.substring(MSD, stop)

    if (tempstr.indexOf(".") != -1)
        digits = digits - 1

    number = digits
    if (precision < digits)
        number = precision

    tempstr = input.substring(MSD, MSD + number + 1)

    if ( (MSD != start) || (tempstr.indexOf(".") == -1) )
    {
        result = signstr
        result += input.substring(MSD, MSD + 1)
        result += "."
        result += input.substring(MSD + 1, MSD + number)

        while (digits < precision)
        {
            result += "0"
            digits += 1
        }

        result += expstr
    }
    else
    {
        result = input.substring(0, start + number + 1)

        while (digits < precision)
        {
            result += "0"
            digits += 1
        }

        if (input.length != stop)
            result += input.substring(locE, input.length)
    }

    return result;
}

function numCutOff(input, precision)
{
    result = new String()
    tempstr = new String()

    var temp = input;
    if(temp < 1)
        temp += 1;

    tempstr = "" + temp;

    tempstr = numStrClipOff(tempstr, precision);

    if(temp == input)
        result = tempstr.substring(0, 1);
    else
        result = "0";

    result += tempstr.substring(1, tempstr.length);

    return result;
}

function Convert2Dec()
{
    output = new String()

    var s, i, dp, val, hid, temp, decValue, power

    with (Math)
    {
        if (this.Size == 32) s = 9
        else s = 12

        if ((this.BinaryPower < this.MinExp) || (this.BinaryPower > this.MaxExp))
        {
            dp = 0
            val = 0
        }
        else
        {
            dp = - 1
            val = 1
        }

        for (i = s; i < this.Size; i++)
            val += parseInt(this.Result[i])*pow(2, dp + s - i)

        decValue = val * pow(2, this.BinaryPower)

        if (this.Size == 32)
        {
            s = 8
            if (val > 0)
            {
                power = floor( log(decValue) / LN10 )
                decValue += 0.5 * pow(10, power - s + 1)
                val += 5E-8
            }
        }
        else s = 17

        if (this.Result[0] == 1) decValue = - decValue

        //the system refuses to display negative "0"s with a minus sign
        this.DecValue = "" + decValue
        if ((this.DecValue == "0") && (this.Result[0] == 1))
            this.DecValue = "-" + this.DecValue

        this.DecValue = numStrClipOff(this.DecValue, s)

        output = numCutOff(val, s)

    }
    return output
}

//object construction function
function ieee (Size){

    this.Size = Size
    this.BinaryPower = 0
    this.DecValue = ""
    this.DispStr = ""
    this.Convert2Bin = Convert2Bin   //convert input to bin.
    this.Convert2Hex = Convert2Hex   //convert bin. to hex.
    this.Convert2Dec = Convert2Dec   //convert bin. significand to dec.
    this.Dec2Bin = Dec2Bin           //convert dec. to bin.
    this.StatCond = "normal"
    this.StatCond64 = "normal"
    this.BinString = ""
    // 1 (carry bit) + 1023 + 1 + 1022 + 53 + 2 (round bits)
    this.BinVal = new Array(2102)    //Binary Representation
    if (Size == 32){
        this.ExpBias = 127
        this.MaxExp = 127
        this.MinExp = -126
        this.MinUnnormExp = -149
        this.Result = new Array(32)
    }
    else if (Size == 64){
        this.ExpBias = 1023
        this.MaxExp = 1023
        this.MinExp = -1022
        this.MinUnnormExp = -1074
        this.Result = new Array(64)
    }

}

function compute(obj, rounding){
    /*
      in this javascript program, bit positions are numbered
      0 ~ 32/64 from left to right instead of right to left, the
      way the output is presented
    */
    ieee32 = new ieee(32)
    ieee64 = new ieee(64)

    var input, index1, cnst

    input = obj.input.value
    input = RemoveBlanks(input)

    ieee64.Dec2Bin(input)
    ieee64.BinString =
        ieee64.Convert2Bin(ieee64.DispStr, ieee64.StatCond64, ieee64.Result[0],
            ieee64.BinaryPower, false)
    obj.bin64_0.value = ieee64.BinString.substring(0, 1)
    obj.bin64_1.value = ieee64.BinString.substring(1, 12)
    if ((ieee64.BinaryPower < ieee64.MinExp) ||
        (ieee64.BinaryPower > ieee64.MaxExp))
    {
        obj.bin64_12.value = "  "
        obj.bin64_12.value += ieee64.BinString.substring(12, 13)
        obj.bin64_12.value += "."
        obj.bin64_12.value += ieee64.BinString.substring(13, 64)
    }
    else
    {
        obj.bin64_12.value = "1 ."
        obj.bin64_12.value += ieee64.BinString.substring(12, 64)
    }
    obj.stat64.value = ieee64.StatCond
    obj.binpwr64.value = ieee64.BinaryPower
    obj.binpwr64f.value = ieee64.BinaryPower + ieee64.ExpBias
    obj.dec64sig.value = ieee64.Convert2Dec()
    if (ieee64.DispStr != "")
    {
        obj.dec64.value = ieee64.DispStr
        obj.dec64sig.value = ""
    }
    else
        obj.dec64.value = ieee64.DecValue
    obj.hex64.value = ieee64.Convert2Hex()

    cnst = 2102         // 1 (carry bit) + 1023 + 1 + 1022 + 53 + 2 (round bits)
    for (index1 = 0; index1 < cnst; index1++)
        ieee32.BinVal[index1] = ieee64.BinVal[index1]

    ieee32.BinString =
        ieee32.Convert2Bin(ieee64.DispStr, ieee64.StatCond64, ieee64.Result[0],
            ieee64.BinaryPower, rounding)
    obj.bin32_0.value = ieee32.BinString.substring(0, 1)
    obj.bin32_1.value = ieee32.BinString.substring(1, 9)
    if ((ieee32.BinaryPower < ieee32.MinExp) ||
        (ieee32.BinaryPower > ieee32.MaxExp))
    {
        obj.bin32_9.value = "  "
        obj.bin32_9.value += ieee32.BinString.substring(9, 10)
        obj.bin32_9.value += "."
        obj.bin32_9.value += ieee32.BinString.substring(10, 32)
    }
    else
    {
        obj.bin32_9.value = "1 ."
        obj.bin32_9.value += ieee32.BinString.substring(9, 32)
    }
    obj.stat32.value = ieee32.StatCond
    obj.binpwr32.value = ieee32.BinaryPower
    obj.binpwr32f.value = ieee32.BinaryPower + ieee32.ExpBias
    obj.dec32sig.value = ieee32.Convert2Dec()
    if (ieee32.DispStr != "")
    {
        obj.dec32.value = ieee32.DispStr
        obj.dec32sig.value = ""
    }
    else
        obj.dec32.value = ieee32.DecValue
    obj.hex32.value = ieee32.Convert2Hex()

    if ((ieee64.DispStr != "") && (ieee32.DispStr != ""))
        obj.entered.value = ieee64.DispStr
    else
        obj.entered.value = input * 1.0
}

// Additions for pascal.js

function llvm_double_hex(input) {
    ieee64 = new ieee(64)
    ieee64.Dec2Bin(input.toString())
    ieee64.BinString =
        ieee64.Convert2Bin(ieee64.DispStr, ieee64.StatCond64, ieee64.Result[0],
            ieee64.BinaryPower, false)
    return '0x' + ieee64.Convert2Hex()
};
function llvm_float_hex(input) {
    var d64 = llvm_double_hex(input);
    //return d64.replace(/(.*)........$/, "$100000000");
    return d64.replace(/(.*)........$/, "$1A0000000");
};

if (typeof module !== 'undefined') {
    exports.llvm_float_hex = llvm_float_hex;
    exports.llvm_double_hex = llvm_double_hex;
} else {
    var ieee754 = {llvm_float_hex:llvm_float_hex,
        llvm_double_hex:llvm_double_hex};
}


"use strict";

function id(identifier) {
    return identifier.split('-').join('_').replace('?', '$');
}

function isNode() {
    return typeof process === 'object' && typeof require === 'function';
}

function SymbolTable() {
    var data = [{}],
        name_cnt = 0;

    function begin_scope() {
        data.push({});
    }
    function end_scope() {
        if (data.length === 1) {
            throw new Error("end_scope without begin_scope");
        }
        data.pop();
    }

    function indexOf(name) {
        for(var idx = data.length-1; idx >= 0; idx--) {
            if (data[idx][name]) {
                return idx;
            }
        }
        return undefined;
    }

    function lookup(name) {
        var name = name.toUpperCase(),
            idx = indexOf(name);
        if (typeof(idx) !== "undefined") {
            return data[idx][name];
        }
        throw new Error("Name '" + name + "' not found in symbol table");
    }

    function insert(name, value, level) {
        if (typeof level === 'undefined') { level = data.length-1; }
        data[level][name.toUpperCase()] = value;
    }

    // insert a definition for unit procedure/function
    function unit_pinsert(name, evalfn, fparams, rettype) {
        var kind = rettype ? 'func' : 'proc',
            decl = {node:kind + '_decl',name:name,evalfn:evalfn,level:0,
                type:rettype,lparams:[],fparams:[]};
        for (var i=0; i < fparams.length; i++) {
            var fparam = fparams[i];
            fparam.node = 'param';
            fparam.id = "param" + i;
            decl.fparams.push(fparam);
        }
        insert(name,decl);
    }

    function replace(name, value) {
        var name = name.toUpperCase(),
            idx = indexOf(name);
        if (typeof(idx) !== "undefined") {
            data[idx][name] = value;
        } else {
            throw new Error("Name '" + name + "' not found to replace");
        }
    }

    function new_name(name) {
        return name + "_" + (name_cnt++) + "_";
    }

    function display(all) {
        console.warn("-------------");
        for(var idx = 0; idx < data.length; idx++) {
            console.warn("--- " + idx + " ---");
            for(var name in data[idx]) {
                if (all || !data[idx][name].evalfn) {
                    console.warn(name + ": ", data[idx][name]);
                }
            }
        }
        console.warn("-------------");
    }

    return {lookup: lookup,
        insert: insert,
        unit_pinsert: unit_pinsert,
        replace: replace,
        begin_scope: begin_scope,
        end_scope: end_scope,
        new_name: new_name,
        display: display};
};

function IR(theAST) {

    var st = new SymbolTable(),
        str_cnt = 0,
        default_units = ['SYSTEM'];

    // Store global settings in the symbol table
    st.insert('_settings_', {});

    function load_unit(unit) {
        var lib = null,
            unit_path = './units/' + unit.toLowerCase() + ".js",
            unit_name = unit.toUpperCase();
        if (isNode()) {
            // Node.js
            var rlib = require(unit_path),
                lib = new rlib[unit_name](st);
        } else if (typeof window[unit_name] !== 'undefined') {
            // Browser - already loaded
            console.log("unit_name: " + unit_name);
            lib = new window[unit_name](st);
        } else {
            // Browser - Synchronous AJAX request
            var xhr = new XMLHttpRequest();
            xhr.open('GET', unit_path, false);
            xhr.send(null);
            lib = new (eval(xhr.responseText))(st);
        }
        return lib;
    }

    function copy_type(obj) {
        var copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
        }
        return copy;
    }

    function expand_type(type) {
        var t = copy_type(type);
        while (t.name === 'NAMED') {
            var tdecl = st.lookup(t.id);
            t = tdecl.type;
        }
        return t;
    }

    // Resolve a type definition to add lltype containing LLVM type
    // string. If the type is a named type then it will be resolved to
    // a base type first.
    function normalize_type(type) {
        var t = expand_type(type), // implicit copy
            lltype, vdef = "0",
            name = (typeof t.origname !== 'undefined') ? t.origname : t.name;
        switch (name) {
            case 'REAL':      lltype = "float"; vdef = "0.0"; break;

            // structured datatypes
            case 'STRING':
                if (typeof t.type === 'undefined') {
                    t.type = {node:'type',name:'CHARACTER'};
                }
                t.type = normalize_type(t.type);
                lltype = "i8*";
                vdef = "null";
                break;
            case 'ARRAY':
                var start, end, vdefs, ttype;
                t.index = normalize_type(t.index);
                t.type = normalize_type(t.type);
                start = t.index.start;
                end = t.index.end;
                vdefs = [];
                ttype = t.type;
                lltype = '[' + (end-start+1) + ' x ' + ttype.lltype + ']';
                for (var i=0; i < end-start+1; i++) {
                    vdefs.push(ttype.lltype + ' ' + ttype.default_value);
                }
                vdef = '[' + vdefs.join(', ') + ']';
                break;
            case 'RECORD':
                var comps = [], vdefs = [],
                    sections = t.sections;
                t.component_map = {};
                for (var i=0; i<sections.length; i++) {
                    var comp = sections[i];
                    comp.type = normalize_type(comp.type);
                    comps.push(comp.type.lltype);
                    vdefs.push(comp.type.lltype + ' ' + comp.type.default_value);
                    t.component_map[comp.id] = i;
                }
                lltype = "{" + comps.join(", ") + "}";
                vdef = '{' + vdefs.join(', ') + '}';
                break;

            // INTEGER types
            case 'INTEGER':
                if (typeof t.origname === 'undefined') {
                    t.origname = 'INTEGER';
                }
                lltype = "i32";
                vdef = 0;
                start = -32768;
                end = 32767;
                break;
            case 'BYTE':
                t.name = 'INTEGER';
                t.origname = 'BYTE';
                lltype = "i8";
                vdef = 0;
                start = 0;
                end = 255;
                break;
            case 'CHARACTER':
                t.name = 'INTEGER';
                t.origname = 'CHARACTER';
                lltype = "i8";
                vdef = 0;
                start = 0;
                end = 255;
                break;
            case 'SUBRANGE':
                if (typeof t.origname !== 'undefined') {
                    break;
                }
                t.name = 'INTEGER';
                vdef = 0;

                var start = t.start,
                    end = t.end,
                    stype1, stype2;
                if (start.stype === 'variable') {
                    var decl1 = st.lookup(t.start.val),
                        type1 = normalize_type(decl1.type);
                    stype1 = type1.name;
                    start = type1.default_value;

                    if (type1.origname === 'ENUMERATION') {
                        t.origname = type1.origname;
                        t.ids = type1.ids;
                    } else if (typeof type1.origname !== 'undefined') {
                        t.origname = type1.origname;
                    } else {
                        t.origname = stype1;
                    }
                    t.lltype = type1.lltype;
                } else {
                    stype1 = start.stype;
                    start = start.val;
                    t.origname = stype1;

                    switch (stype1) {
                        case 'BOOLEAN':   t.lltype = 'i1'; break;
                        case 'BYTE':      t.lltype = 'i8'; break;
                        case 'CHARACTER': t.lltype = 'i8'; break;
                        case 'INTEGER':   t.lltype = 'i32'; break;
                        default: throw new Error("Unknown SUBRANGE type: " + stype1);
                    }
                }

                if (end.stype === 'variable') {
                    var decl2 = st.lookup(t.end.val),
                        type2 = normalize_type(decl2.type);
                    stype2 = type2.name;
                    end = type2.default_value;
                } else {
                    stype2 = end.stype;
                    end = end.val;
                }
                if (stype1 !== stype2) {
                    throw new Error("Subrange of different types: " + stype1 + ' & ' + stype2);
                }
                if (typeof start !== 'number' || typeof end !== 'number') {
                    throw new Error("TODO: support more complex constants in subrange definitions");
                }
                t.start = start;
                t.end = end;
                break;
            case 'BOOLEAN':
                t.origname = 'BOOLEAN';
                t.ids = ['FALSE', 'TRUE'];
                lltype = 'i1';
            // fall through since BOOLEAN is an enumeration type
            case 'ENUMERATION':
                t.name = 'INTEGER';
                vdef = 0;

                // Enums/bools are really just INTEGER with additional metadata
                if (typeof t.enum_type === 'undefined') {
                    var tdecl = st.lookup(t.ids[0]);
                    t.enum_type = tdecl.type.enum_type;
                    t.enum_var = tdecl.type.enum_var;
                    if (typeof t.origname === 'undefined') {
                        t.origname = tdecl.type.origname;
                    }
                } else if (typeof t.origname === 'undefined') {
                    t.origname = t.name;
                }

                var ecnt = t.ids.length;
                if (typeof lltype === 'undefined') {
                    lltype = "i8";
                }
                t.start = 0;
                t.end = ecnt - 1;
                break;
            default: throw new Error("TODO: handle " + t.name + " type");
        }
        if (typeof t.lltype === 'undefined') {
            // don't stomp alternate INTEGER lltypes
            t.lltype = lltype;
        }
        if (typeof t.default_value === 'undefined') {
            t.default_value = vdef;
        }
        return t;
    }

    function isScalar(type) {
        var t = expand_type(type);
        var res = false;
        // BOOLEAN, BYTE, CHARACTER, etc are all name INTEGER with an
        // origname subtype
        switch (t.name) {
            case 'INTEGER':   res = true; break;
            case 'REAL':      res = true; break;
        }
        return res;
    }

    function isString(type) {
        var t = expand_type(type);
        return (t.name === 'STRING');
    }

    function isScalarOrString(type) {
        return (isScalar(type) || isString(type));
    }

    function deref_name(lvalue) {
        var id = null,
            lv = lvalue,
            cnames = "";
        do {
            if (lv.node === 'expr_record_deref') {
                cnames = "." + lv.component + cnames ;
            } else if (lv.node === 'expr_array_deref') {
                cnames = "_sub" + cnames;
            } else {
                cnames = lv.id + cnames;
            }
            lv = lv.lvalue;
        } while (lv);
        return cnames;
    }

    function allocate_variable(ir,node,id,fname,type,defval) {
        var pdecl = st.lookup(fname),
            level = pdecl.level,
            vtype = copy_type(type),
            vdef = typeof defval !== 'undefined' ? defval : vtype.default_value;
        vtype.default_value = vdef;

        if (level === 0) {
            // global scope
            var sname = "@" + st.new_name(id);
            ir.push([sname + ' = private global ' + vtype.lltype + ' ' + vdef]);
        } else {
            // sub-program scope
            var sname = "%" + st.new_name(id + "_stack");
            ir.push('  ' + sname + ' = alloca ' + vtype.lltype);
            ir.push('  store ' + vtype.lltype + ' ' + vdef + ', ' + vtype.lltype + '* ' + sname);
        }

        st.insert(id,{node:node,type:vtype,sname:sname,level:pdecl.level});
        return sname;
    }

    function allocate_enums(ir,ids,fname,type,lltype) {
        var ecnt = ids.length,
            vlist = [];
        type.enum_type = '[' + ecnt + ' x i8*]';
        type.enum_var = '@' + st.new_name(type.name);
        type.origname = type.name;
        type.name = 'INTEGER';
        type.lltype = lltype;

        // Declare each ID
        for (var i=0; i < ecnt; i++) {
            var eid = ids[i],
                elen = eid.length + 1,
                eidstr = st.new_name(type.enum_var + '.' + eid),
                eitype = '[' + elen + ' x i8]',
                estr = 'c"' + eid + '\\00"';
            vlist.push('i8* getelementptr inbounds (' + eitype + '* ' + eidstr + ', i32 0, i32 0)');
            ir.push([eidstr + ' = private unnamed_addr constant ' + eitype + ' ' + estr]);
            // Each enumeration element is a var declaration
            allocate_variable(ir,'var_decl',eid.toUpperCase(),fname,type,i);
        }
        // Declare the array of strings for the enum values so that
        // we can print them out if needed
        ir.push([type.enum_var + ' = global ' + type.enum_type + ' [ ' + vlist.join(", ") + ' ]']);
        return type;
    }

    // normalizeIR takes a JSON IR
    function normalizeIR(ir) {
        var prefix = [], body = [];
        body.push("");
        for (var i=0; i < ir.length; i++) {
            if (typeof(ir[i]) === "object") {
                prefix.push.apply(prefix, ir[i]);
            } else {
                body.push(ir[i]);
            }
        }
        return (prefix.concat(body)).join("\n");
    }

    function toIR(astTree, level, fnames) {
        var ast = (typeof astTree === 'undefined') ? theAST : astTree,
            indent = "",
            fname, node,
            ir = [];
        if (! ast) {
            throw new Error("Warning: toIR called with empty/null AST");
        }
        node = ast.node,
            level = level ? level : 0;
        fnames = fnames ? fnames : [];
        fname = fnames[fnames.length-1];
        for (var i=0; i < level; i++) {
            indent = indent + "  ";
        }

        //console.warn("toIR",node,"level:", level, "fnames:", fnames, "ast:", JSON.stringify(ast));

        switch (node) {
            case 'program':
                // Similar to a proc_decl but with declarations and called by
                // @main
                var id = ast.id,
                    fparams = ast.fparams,
                    block = ast.block;

                st.insert(id,{name:id,level:level,fparams:fparams,lparams:[]});

                // Define some predefined variables/constants
                allocate_enums(ir,['FALSE','TRUE'],id,
                    {node:'type',name:'BOOLEAN'},'i1');
                allocate_variable(ir,'const_decl','PI',id,
                    normalize_type({node:'type',name:'REAL'}),
                    ieee754.llvm_float_hex(3.1415926536));
                allocate_variable(ir,'const_decl','MAXINT',id,
                    normalize_type({node:'type',name:'INTEGER'}),32767);

                block.param_list = [];
                try {
                    ir.push.apply(ir, toIR(block,level,fnames.concat([id])));
                } catch(e) {
                    // Catch and report errors with line numbers
                    console.error(e.toString() + " [line " + (e.lineno+1) + "]");
                    throw e;
                }

                ir.push('');
                ir.push('declare i8* @malloc(i64)');
                ir.push('declare i64 @strlen(i8*)');
                ir.push('declare i8* @strncpy(i8*, i8*, i64)');
                ir.push('declare i8* @strncat(i8*, i8*, i64)');
                ir.push('');
                ir.push('define i32 @main() {');
                ir.push('entry:');
                ir.push('  %ret = call i32 @' + id + '()');
                ir.push('  ret i32 0');
                ir.push('}');
                break;

            case 'block':
                var uses = ast.uses,
                    decls = ast.decls,
                    stmts = ast.stmts,
                    pdecl = st.lookup(fname),
                    lparams = pdecl.lparams,
                    fparams = pdecl.fparams,
                    param_list = [],
                    lparam_list = [],
                    unit_init_ir = [],
                    unit_stop_ir = [],
                    pdecl_ir = [],
                    vdecl_ir = [],
                    stmts_ir = [];

                /* Evaluate libraries specified in the 'uses' declaration */
                if (uses) {
                    // Loaded by default
                    var unit_list = default_units.slice();

                    /* user specified */
                    for (var i=0; i<uses.length; i++) {
                        if (unit_list.indexOf(uses[i]) < 0) {
                            unit_list.push(uses[i]);
                        }
                    }

                    for (var i=0; i<unit_list.length; i++) {
                        var unit = unit_list[i],
                            lib = load_unit(unit);
                        unit_init_ir.push.apply(unit_init_ir, lib.init());
                        unit_stop_ir.push.apply(unit_stop_ir, lib.stop());
                    }
                }

                // Regular formal parameters
                for (var i=0; i < fparams.length; i++) {
                    var fparam = fparams[i];
                    fparam.type = normalize_type(fparam.type);
                    var ftype = fparam.type,
                        lltype = ftype.lltype,
                        pname = "%" + st.new_name(fparam.id + "_fparam"),
                        sname = "%" + st.new_name(fparam.id + "_fparam_stack");
                    if (fparam.var) {
                        vdecl_ir.push('  ' + pname + ' = load ' + lltype + '* ' + sname);
                        param_list.push(lltype + '* ' + sname);
                    } else {
                        vdecl_ir.push('  ' + sname + ' = alloca ' + lltype);
                        vdecl_ir.push('  store ' + lltype + ' ' + pname + ', ' + lltype + '* ' + sname);
                        param_list.push(lltype + ' ' + pname);
                    }
                    st.insert(fparam.id,{node:'var_decl',type:ftype,pname:pname,sname:sname,var:fparam.var,level:level});
                }

                // Evaluate the children. We might need to modify the
                // param-list based on internal variables that refer to higher
                // level lexical scope
                var curAst = null;
                try {
                    for (var i=0; i < decls.length; i++) {
                        var decl = decls[i];
                        curAst = decl;
                        if (decl.node === 'proc_decl' || decl.node === 'func_decl') {
                            pdecl_ir.push.apply(pdecl_ir, toIR(decl,level,fnames));
                        } else {
                            vdecl_ir.push.apply(vdecl_ir, toIR(decl,level,fnames));
                        }
                    }
                    for (var i=0; i < stmts.length; i++) {
                        curAst = stmts[i];
                        stmts_ir.push.apply(stmts_ir, toIR(stmts[i],level,fnames));
                    }
                } catch (e) {
                    // Add the line number to the exception but only if it's not
                    // already set, otherwise we would stomp a more specific
                    // line number
                    if (typeof e.lineno === 'undefined') {
                        e.lineno = curAst.lineno;
                    }
                    throw e;
                }

                // Variables that refer to higher lexical scope
                for (var i=0; i < lparams.length; i++) {
                    var lparam = lparams[i],
                        ldecl = st.lookup(lparam.id),
                        sname = ldecl.sname;
                    ldecl.type = normalize_type(ldecl.type);
                    lparam_list.push(ldecl.type.lltype + '* ' + sname);
                }
                param_list = lparam_list.concat(param_list);

                // Now output the IR
                // Add sub-program declarations at the top level
                var pitype = pdecl.itype || "i32";
                ir.push.apply(ir, pdecl_ir);
                ir.push('');
                ir.push('define ' + pitype + ' @' + pdecl.name + '(' + param_list.join(", ") +') {');
                ir.push('entry:');
                ir.push.apply(ir, unit_init_ir);
                // For functions, add the return parameter
                if (pdecl.ireturn) {
                    ir.push('  %retval = alloca ' + pitype);
                }
                // Add variable declarations inside the body definition
                ir.push.apply(ir, vdecl_ir);
                // Postpone variable declarations until inside the body
                ir.push.apply(ir, stmts_ir);
                if (pdecl.ireturn) {
                    ir.push('  %retreg = load ' + pitype + '* %retval');
                    ir.push('  ret ' + pitype + ' %retreg');
                } else {
                    ir.push('  ret ' + pitype + ' 0');
                }
                ir.push.apply(ir, unit_stop_ir);
                ir.push('}');
                break;

            case 'type_decl':
                var id = ast.id;
                ast.type = expand_type(ast.type);
                if (ast.type.name === 'ENUMERATION') {
                    ast.type = allocate_enums(ir,ast.type.ids,fname,ast.type,'i8');
                }
                ast.type = normalize_type(ast.type);
                st.insert(id,{node:'type_decl',id:id,type:ast.type});
                break;

            case 'var_decl':
                ast.type = expand_type(ast.type);
                if (ast.type.name === 'ENUMERATION') {
                    allocate_enums(ir,ast.type.ids,fname,ast.type,'i8');
                }
                ast.type = normalize_type(ast.type);
                allocate_variable(ir,'var_decl',ast.id,fname,ast.type);
                break;

            case 'const_decl':
                var id = ast.id,
                    expr = ast.expr;

                ir.push.apply(ir, toIR(expr,level,fnames));
                expr.type = normalize_type(expr.type);

                var sname = allocate_variable(ir,'const_decl',id,fname,expr.type,expr.val);

                ir.push('  store ' + expr.itype + ' ' + expr.ilocal + ', ' + expr.itype + '* ' + sname);
                break;

            case 'proc_decl':
            case 'func_decl':
                var id = ast.id,
                    type = ast.type,
                    fparams = ast.fparams,
                    block = ast.block,
                    new_level = level+1;

                st.insert(id, {name: id, type:type, level: new_level,fparams:fparams,lparams:[]});
                if (block !== 'forward') {
                    st.begin_scope();
                    ir.push.apply(ir, toIR(block,new_level,fnames.concat([id])));
                    st.end_scope();
                }
                break;

            case 'stmt_assign':
                var lvalue = ast.lvalue,
                    expr = ast.expr;
                ir.push('  ; ASSIGN start');
                ir.push.apply(ir,toIR(expr,level,fnames));
                var litype = null, listack = null;

                if (lvalue.id === fname) {
                    // This is actually a function name being used to set the
                    // return value for the function so we don't evaluate the
                    // lvalue
                    var pdecl = st.lookup(fname);
                    pdecl.type = normalize_type(pdecl.type);
                    lvalue.type = pdecl.type;
                    lvalue.itype = pdecl.type.lltype;
                    pdecl.ireturn = true;
                    pdecl.itype = lvalue.itype;
                    st.replace(fname,pdecl);
                    litype = lvalue.itype;
                    listack = "%retval";
                } else {
                    ir.push.apply(ir,toIR(lvalue,level,fnames));
                    litype = lvalue.itype;
                    listack = lvalue.istack;
                }

                if (lvalue.type.name === 'STRING' && expr.type.name === 'STRING' && expr.val) {
                    // string literal being assigned to string variable
                    ir.push('  store i8* getelementptr inbounds (' + expr.itype + ' ' + expr.istack + ', i32 0, i32 0), ' + litype + '* ' + listack);
                } else if (lvalue.type.name === 'STRING' && expr.type.name === 'STRING') {
                    // string being assigned to string so malloc and copy
                    var slen1 = '%' + st.new_name('slen'),
                        slen2 = '%' + st.new_name('slen'),
                        lvar = '%' + st.new_name('lvar'),
                        decay1 = '%' + st.new_name('arraydecay'),
                        decay2 = '%' + st.new_name('arraydecay'),
                        chr = '%' + st.new_name('chr'),
                        res = '%' + st.new_name('res');
                    ir.push('  ' + slen1 + ' = call i64 @strlen(i8* ' + expr.ilocal + ')');
                    ir.push('  ' + slen2 + ' = add i64 1, ' + slen1);
                    ir.push('  ' + lvar + ' = call i8* @malloc(i64 ' + slen2 + ')');
                    ir.push('  store i8* ' + lvar + ', ' + litype + '* ' + listack);
                    ir.push('  ' + res + ' = call i8* @strncpy(i8* ' + lvar + ', i8* ' + expr.ilocal + ', i64 ' + slen2 + ')');
                } else if (lvalue.type.name === 'REAL' && expr.type.name === 'INTEGER') {
                    // coerce integer to real
                    var conv = st.new_name("%conv");
                    ir.push('  ' + conv + ' = sitofp i32 ' + expr.ilocal + ' to float');
                    ir.push('  store float ' + conv + ', ' + litype + '* ' + listack);
                } else if (lvalue.type.origname === 'BYTE' && expr.type.origname === 'INTEGER') {
                    // coerce integer to byte
                    var conv = st.new_name("%conv");
                    ir.push('  ' + conv + ' = trunc i32 ' + expr.ilocal + ' to i8');
                    ir.push('  store i8 ' + conv + ', ' + litype + '* ' + listack);
                } else if (lvalue.type.name !== expr.type.name) {
                    throw new Error("Type of lvalue and expression do not match: " + lvalue.type.name + " vs " + expr.type.name);
                } else if (lvalue.type.origname !== expr.type.origname) {
                    throw new Error("Subtype of lvalue and expression do not match: " + lvalue.type.origname + " vs " + expr.type.origname);
                } else {
                    ir.push('  store ' + expr.itype + ' ' + expr.ilocal + ', ' + litype + '* ' + listack);
                }

                ast.itype = litype;
                ast.istack = listack;
                ast.ilocal = expr.ilocal;
                ir.push('  ; ASSIGN finish');
                break;

            case 'stmt_call':
            case 'expr_call':
                var id = ast.id, pdecl;
                try {
                    pdecl = st.lookup(id);
                } catch (e) {
                    throw new Error("Unknown function '" + id + "'");
                }
                var lparams = pdecl.lparams,
                    fparams = pdecl.fparams,
                    cparams = (ast.call_params || []);
                // evaluate the parameters
                for(var i=0; i < cparams.length; i++) {
                    ir.push.apply(ir, toIR(cparams[i],level,fnames));
                }
                // Check that call params and formal params match length and
                // types
                if (fparams.length === 0 && cparams.length !== 0) {
                    throw new Error("Parameter mismatch calling " + id + ": " +
                        "parameter(s) given but none defined");
                }
                for(var i=0; i < fparams.length; i++) {
                    var cparam = cparams[i],
                        fparam = fparams[i],
                        ftype = fparam.type.name;
                    if (ftype === 'varargs') {
                        // We've checked as far as we can go on this side.
                        // 'varargs' only applies to built-in unit routines and
                        // must be done by the routine evalfn itself
                        break;
                    }
                    if (ftype === 'any') {
                        // The routine can accept multiple types in this position
                        // so assume we're good and continue to the next argument.
                        // 'any' only applies to built-in unit routines and
                        // checking must be done by the routine evalfn itself
                        continue;
                    }
                    if (!cparam) {
                        throw new Error("Parameter mismatch calling " +
                            id + ": more than " + i +
                            " parameter(s) required but " + i +
                            " given")
                    }
                    var cname = cparam.id ? cparam.id : "'" + cparam.val + "'",
                        ctype = cparam.type,
                        ctname = ctype.name,
                        ctoname = ctype.origname;
                    if (ftype === 'multiple') {
                        var ftypes = fparam.type.names;
                        if (ftypes.indexOf(ctname) < 0 &&
                            ftypes.indexOf(ctoname) < 0) {
                            throw new Error("Parameter mismatch calling " +
                                id + ": " + cname + ":" + ctname +
                                " given, but definition is " + ftypes);
                        }
                    } else {
                        if (ctname !== ftype) {
                            throw new Error("Parameter mismatch calling " +
                                id + ": " + cname + ":" + ctname +
                                " given, but definition is " + ftype);
                        }
                    }
                }
                if (pdecl.evalfn) {
                    // This is a call to built-in unit routine and needs to be
                    // evaluated (in a sense: macro expanded)
                    ir.push.apply(ir, pdecl.evalfn(ast, cparams));
                    if (ast.node === 'expr_call') {
                        ast.type = normalize_type(ast.type);
                    }
                } else {
                    var param_list = [];
                    for(var i=0; i < lparams.length; i++) {
                        var lparam = lparams[i],
                            lltype = null;
                        ir.push.apply(ir, toIR(lparam,level,fnames));
                        lparam.type = normalize_type(lparam.type),
                            param_list.push(lparam.type.lltype + "* " + lparam.istack);
                    }
                    for(var i=0; i < cparams.length; i++) {
                        var cparam = cparams[i],
                            fparam = fparams[i];
                        if (cparams[i].lparam) {
                            throw new Error("TODO handle lparam in call");
                        } else if (fparam.var) {
                            param_list.push(cparam.itype + "* " + cparam.istack);
                        } else if (fparam.type.name === 'STRING' && cparam.itype[0] === '[') {
                            // TODO: above check is ugly, should be better way to distinguish character array from i8* string
                            // coerce character array to i8*
                            param_list.push('i8* getelementptr inbounds (' + cparam.itype + ' ' + cparam.istack + ', i32 0, i32 0)');
                        } else {
                            param_list.push(cparam.itype + " " + cparam.ilocal);
                        }
                    }
                    if (node === 'expr_call') {
                        var ret = '%' + st.new_name(pdecl.name + "_ret");
                        pdecl.type = normalize_type(pdecl.type);
                        var lltype = pdecl.type.lltype;
                        ir.push('  ' + ret + ' = call ' + lltype + ' @' + pdecl.name + "(" + param_list.join(", ") + ")");
                        ast.type = pdecl.type;
                        ast.itype = lltype;
                        ast.ilocal = ret;
                    } else {
                        ir.push('  call i32 @' + pdecl.name + "(" + param_list.join(", ") + ")");
                    }
                }
                break;

            case 'stmt_compound':
                for (var i=0; i < ast.stmts.length; i++) {
                    ir.push.apply(ir,toIR(ast.stmts[i],level,fnames));
                }
                break;

            case 'stmt_if':
                var expr = ast.expr,
                    tstmt = ast.tstmt,
                    fstmt = ast.fstmt;
                ir.push('');
                ir.push('  ; if statement start');
                ir.push.apply(ir, toIR(expr,level,fnames));
                var br_name = st.new_name('br'),
                    br_true = br_name + '_true',
                    br_false = br_name + '_false',
                    br_done = br_name + '_done';
                ir.push('  br ' + expr.itype + ' ' + expr.ilocal + ', label %' + br_true + ', label %' + br_false);
                ir.push(br_true + ':');
                if (tstmt) {
                    ir.push.apply(ir, toIR(tstmt,level,fnames));
                }
                ir.push('  br label %' + br_done);
                ir.push(br_false + ':');
                if (fstmt) {
                    ir.push.apply(ir, toIR(fstmt,level,fnames));
                }
                ir.push('  br label %' + br_done);
                ir.push(br_done + ':');
                ir.push('  ; if statement finish');
                ir.push('');
                break;

            case 'stmt_case':
                var expr = ast.expr,
                    cases = ast.cases,
                    otherwise_stmt = ast.otherwise_stmt,
                    br_name = st.new_name('br'),
                    br_done = br_name + '_done';

                ir.push('');
                ir.push('  ; case statement start');
                ir.push.apply(ir, toIR(expr,level,fnames));

                for (var i=0; i < cases.length; i++) {
                    var indexes = cases[i].indexes,
                        stmt = cases[i].stmt;
                    for (var j=0; j < indexes.length; j++) {
                        var index = indexes[j],
                            cmp = st.new_name('%' + br_name + '_cmp'),
                            cmp2 = st.new_name('%' + br_name + '_cmp'),
                            br_curr = st.new_name(br_name),
                            br_curr2 = st.new_name(br_name),
                            br_next = st.new_name(br_name);
                        if (index.node === 'constant') {
                            ir.push('  ' + cmp + ' = icmp eq i32 ' + index.val + ', ' + expr.ilocal);
                            ir.push('  br i1 ' + cmp + ', label %' + br_curr + ', label %' + br_next);
                        } else {
                            ir.push('  ' + cmp + ' = icmp sgt i32 ' + index.start.val + ', ' + expr.ilocal);
                            ir.push('  br i1 ' + cmp + ', label %' + br_next + ', label %' + br_curr2);
                            ir.push(br_curr2 + ':');
                            ir.push('  ' + cmp2 + ' = icmp slt i32 ' + index.end.val + ', ' + expr.ilocal);
                            ir.push('  br i1 ' + cmp2 + ', label %' + br_next + ', label %' + br_curr);
                        }
                        ir.push(br_curr + ':');
                        ir.push.apply(ir, toIR(stmt,level,fnames));
                        ir.push('  br label %' + br_done);
                        ir.push(br_next + ':');
                    }
                }
                if (otherwise_stmt) {
                    ir.push('  ; case statement otherwise');
                    ir.push.apply(ir, toIR(otherwise_stmt,level,fnames));
                }
                ir.push('  br label %' + br_done);
                ir.push(br_done + ':');
                ir.push('  ; case statement finish');
                break;

            case 'stmt_for':
                var index = ast.index,
                    start = ast.start,
                    by = ast.by,
                    end = ast.end,
                    stmt = ast.stmt,
                    for_label = st.new_name('for'),
                    for_start = for_label + 'start',
                    for_cond = for_label + 'cond',
                    for_body = for_label + 'body',
                    for_inc = for_label + 'inc',
                    for_end = for_label + 'end',
                    for_cmp = '%' + for_label + 'cmp',
                    for_cmp1 = '%' + for_label + 'cmp1',
                    for_cmp2 = '%' + for_label + 'cmp2',
                    for_inc1 = '%' + for_label + 'inc1',
                    for1 = '%' + for_label + '1',
                    for2 = '%' + for_label + '2',
                    for3 = '%' + for_label + '3';

                ir.push('');
                ir.push('  ; for statement start');

                ir.push.apply(ir, toIR(index,level,fnames));
                ir.push.apply(ir, toIR(start,level,fnames));
                ir.push.apply(ir, toIR(end,level,fnames));

                if (by === 1) {
                    ir.push('  ' + for_cmp + ' = icmp sgt i32 ' + start.ilocal + ', ' + end.ilocal);
                } else {
                    ir.push('  ' + for_cmp + ' = icmp slt i32 ' + start.ilocal + ', ' + end.ilocal);
                }
                ir.push('  br i1 ' + for_cmp + ', label %' + for_end + ', label %' + for_start);

                ir.push('  br label %' + for_start);

                ir.push('');
                ir.push(for_start + ':');
                ir.push('  store ' + start.itype + ' ' + start.ilocal + ', ' + index.itype + '* ' + index.istack);
                ir.push('  br label %' + for_cond);

                ir.push('');
                ir.push(for_cond + ':');
                ir.push('  ' + for1 + ' = load i32* ' + index.istack);
                if (by === 1) {
                    ir.push('  ' + for_cmp1 + ' = icmp sle i32 ' + for1 + ', ' + end.ilocal);
                } else {
                    ir.push('  ' + for_cmp1 + ' = icmp sge i32 ' + for1 + ', ' + end.ilocal);
                }
                ir.push('  br i1 ' + for_cmp1 + ', label %' + for_body + ', label %' + for_end);

                ir.push('');
                ir.push(for_body + ':');
                ir.push.apply(ir, toIR(stmt,level,fnames));
                ir.push('  ' + for2 + ' = load i32* ' + index.istack);
                ir.push('  ' + for_cmp2 + ' = icmp eq i32 ' + for2 + ', ' + end.ilocal);
                ir.push('  br i1 ' + for_cmp2 + ', label %' + for_end + ', label %' + for_inc);

                ir.push('');
                ir.push(for_inc + ':');
                ir.push('  ' + for3 + ' = load i32* ' + index.istack);
                ir.push('  ' + for_inc1 + ' = add nsw i32 ' + for3 + ', ' + by);
                ir.push('  store i32 ' + for_inc1 + ', i32* ' + index.istack);
                ir.push('  br label %' + for_cond);

                ir.push('');
                ir.push(for_end + ':');

                ir.push('  ; for statement finish');
                ir.push('');
                break;

            case 'stmt_repeat':
                var expr = ast.expr,
                    stmts = ast.stmts,
                    repeat_label = st.new_name('repeat'),
                    repeat_cond = repeat_label + 'cond',
                    repeat_body = repeat_label + 'body',
                    repeat_end = repeat_label + 'end';

                ir.push('');
                ir.push('  ; repeat statement start');

                ir.push('  br label %' + repeat_body);

                ir.push('');
                ir.push(repeat_body + ':');
                for (var i=0; i < stmts.length; i++) {
                    ir.push.apply(ir,toIR(stmts[i],level,fnames));
                }
                ir.push('  br label %' + repeat_cond);

                ir.push('');
                ir.push(repeat_cond + ':');
                ir.push.apply(ir, toIR(expr,level,fnames));
                ir.push('  br i1 ' + expr.ilocal + ', label %' + repeat_end + ', label %' + repeat_body);

                ir.push('');
                ir.push(repeat_end + ':');

                ir.push('  ; repeat statement finish');
                ir.push('');
                break;

            case 'stmt_while':
                var expr = ast.expr,
                    stmt = ast.stmt,
                    while_label = st.new_name('while'),
                    while_cond = while_label + 'cond',
                    while_body = while_label + 'body',
                    while_end = while_label + 'end';

                ir.push('');
                ir.push('  ; while statement start');

                ir.push('  br label %' + while_cond);

                ir.push('');
                ir.push(while_cond + ':');
                ir.push.apply(ir, toIR(expr,level,fnames));
                ir.push('  br i1 ' + expr.ilocal + ', label %' + while_body + ', label %' + while_end);

                ir.push('');
                ir.push(while_body + ':');
                ir.push.apply(ir, toIR(stmt,level,fnames));
                ir.push('  br label %' + while_cond);

                ir.push('');
                ir.push(while_end + ':');

                ir.push('  ; while statement finish');
                ir.push('');
                break;

            case 'expr_binop':
                var left = ast.left, ltype,
                    right = ast.right, rtype,
                    resType = null, op,
                    dest_name = '%' + st.new_name("binop"),
                    boolLookup = {gt:'sgt',lt:'slt',
                        geq:'sge',leq:'sle',
                        eq:'eq',neq:'ne'},
                    intLookup = {plus:'add',minus:'sub',
                        star:'mul',slash:'sdiv',
                        div:'sdiv',mod:'urem'},
                    fltLookup = {plus:'fadd',minus:'fsub',
                        star:'fmul',slash:'fdiv'};

                ir.push.apply(ir, toIR(left,level,fnames));
                ir.push.apply(ir, toIR(right,level,fnames));
                ltype = left.type = normalize_type(left.type);
                rtype = left.type = normalize_type(right.type);
                if (ast.op in {gt:1,lt:1,geq:1,leq:1,eq:1,neq:1}) {
                    var msgPrefix = "Operands for '" + ast.op + "' ";
                    // Type-check
                    if (ltype.name !== rtype.name) {
                        throw new Error(msgPrefix + "are not the same type: " + JSON.stringify(ast));
                    }
                    if (ast.op in {gt:1,lt:1}) {
                        // scalar, string
                        if (! (isScalarOrString(ltype) && isScalarOrString(rtype))) {
                            throw new Error(msgPrefix + "are not scalar or string");
                        }
                    } else if (ast.op in {geq:1,leq:1}) {
                        // scalar, string, set
                        // TODO: sets
                        if (! (isScalarOrString(ltype) && isScalarOrString(rtype))) {
                            throw new Error(msgPrefix + "are not scalar or string");
                        }
                    } else if (ast.op in {eq:1,neq:1}) {
                        // scalar, string, set or pointer types
                        // TODO: sets and pointers
                        if (! (isScalarOrString(ltype) && isScalarOrString(rtype))) {
                            throw new Error(msgPrefix + "are not scalar or string");
                        }
                    }
                    if (ltype.name === 'REAL') {
                        op = 'ficmp ' + boolLookup[ast.op];
                    } else {
                        op = 'icmp ' + boolLookup[ast.op];
                    }
                    resType = normalize_type({node:'type',name:'BOOLEAN'});
                } else if (ast.op === "plus" &&
                    (ltype.name === 'STRING' || ltype.origname === 'CHARACTER') &&
                    (rtype.name === 'STRING' || rtype.origname === 'CHARACTER')) {
                    // string concatenation shorthand
                    resType = normalize_type({node:'type',name:'STRING'});
                } else if (ast.op in {plus:1,minus:1,star:1,slash:1,div:1,mod:1}) {
                    if (ast.op === 'slash') {
                        resType = normalize_type({node:'type',name:'REAL'});
                    } else if ((ltype.name === 'INTEGER' && rtype.name === 'INTEGER') ||
                        (ltype.name === 'REAL' && rtype.name === 'REAL')) {
                        resType = ltype;
                    } else if (ltype.name === 'REAL' && rtype.name === 'INTEGER') {
                        resType = ltype;
                    } else if (ltype.name === 'INTEGER' && rtype.name === 'REAL') {
                        resType = rtype;
                    } else {
                        throw new Error("No defined behavior for " +
                            ltype.name + " " + ast.op + " " + rtype.name);
                    }
                    if (resType.name === 'REAL' && ast.op === 'div') {
                        throw new Error("div can only be used with Integers");
                    }
                    if (resType.name === 'REAL') {
                        op = fltLookup[ast.op];
                    } else {
                        op = intLookup[ast.op];
                    }
                } else if (ast.op in {and:1,or:1}) {
                    op = ast.op;
                    resType = left.type;
                } else {
                    throw new Error("Unexpected expr_binop operand " + ast.op);
                }
                if (resType.name === 'REAL' && ltype.name === 'INTEGER') {
                    var conv = st.new_name("%conv");
                    ir.push('  ' + conv + ' = sitofp i32 ' + left.ilocal + ' to float');
                    left.ilocal = conv;
                    left.itype = 'float';
                }
                if (resType.name === 'REAL' && rtype.name === 'INTEGER') {
                    var conv = st.new_name("%conv");
                    ir.push('  ' + conv + ' = sitofp i32 ' + right.ilocal + ' to float');
                    right.ilocal = conv;
                    right.itype = 'float';
                }
                if (resType.name === 'STRING') {
                    // string concatenation shorthand
                    var fake_expr = {node:'expr_call',id:'CONCAT',call_params:[left, right]};
                    ir.push.apply(ir, toIR(fake_expr,level,fnames));
                    dest_name = fake_expr.ilocal;
                } else {
                    ir.push('  ' + dest_name + ' = ' + op + ' ' + left.itype + ' ' + left.ilocal + ', ' + right.ilocal);
                }
                ast.type = resType;
                ast.itype = resType.lltype;
                ast.ilocal = dest_name;
                break;

            case 'expr_unop':
                var expr = ast.expr,
                    dest_name = '%' + st.new_name("unop"),
                    op;
                ir.push.apply(ir, toIR(expr,level,fnames));
                // TODO: real typechecking comparison
                switch (ast.op) {
                    case 'minus':
                        ir.push('  ' + dest_name + ' = sub i32 0, ' + expr.ilocal);
                        break;
                    case 'not':
                        ir.push('  ' + dest_name + ' = xor i1 1, ' + expr.ilocal);
                        break;
                    default: throw new Error("Unexpected expr_unop operand " + ast.op);
                }
                ast.type = expr.type;
                ast.itype = expr.itype;
                ast.ilocal = dest_name;
                break;

            case 'expr_array_deref':
                var lvalue = ast.lvalue,
                    expr = ast.expr;
                ir.push.apply(ir, toIR(expr,level,fnames));
                ir.push.apply(ir, toIR(lvalue,level,fnames));

                var atype = lvalue.type,
                    start, rtype, ritype,
                    aname = '%' + st.new_name(deref_name(ast)),
                    sub = aname + 'sub',
                    aptr1 = aname + 'ptr1',
                    aoff = aname + 'off',
                    aval = aname + 'val';
                // TODO: bounds checking
                start = atype.index.start;
                rtype = atype.type;
                ritype = atype.type.lltype;
                if (atype.name === 'STRING') {
                    ir.push('  ' + sub + ' = sub ' + expr.itype + ' ' + expr.ilocal + ', ' + start);
                    ir.push('  ' + aptr1 + ' = load ' + atype.lltype + '* ' + lvalue.istack);
                    ir.push('  ' + aoff + ' = getelementptr inbounds ' + atype.lltype + ' ' + aptr1 + ', i32 ' + sub);
                    ir.push('  ' + aval + ' = load ' + atype.lltype + ' ' + aoff);
                } else {
                    ir.push('  ' + sub + ' = sub ' + expr.itype + ' ' + expr.ilocal + ', ' + start);
                    ir.push('  ' + aoff + ' = getelementptr inbounds ' + atype.lltype + '* ' + lvalue.istack + ', i32 0, ' + expr.itype + ' ' + sub);
                    ir.push('  ' + aval + ' = load ' + ritype + '* ' + aoff);
                }
                ast.type = rtype;
                ast.itype = ritype;
                ast.istack = aoff;
                ast.ilocal = aval;
                break;

            case 'expr_record_deref':
                var lvalue = ast.lvalue,
                    comp = ast.component;
                ir.push.apply(ir, toIR(lvalue,level,fnames));
                var cidx = lvalue.type.component_map[comp],
                    ctype = lvalue.type.sections[cidx].type,
                    clltype = ctype.lltype,
                    rname = '%' + st.new_name(deref_name(ast)),
                    roff = rname + '_off',
                    rval = rname + '_val';
                ir.push('  ' + roff + ' = getelementptr inbounds ' + lvalue.itype + '* ' + lvalue.istack + ', i32 0, i32 ' + cidx);
                ir.push('  ' + rval + ' = load ' + clltype + '* ' + roff);
                ast.type = ctype;
                ast.itype = clltype;
                ast.istack = roff;
                ast.ilocal = rval;
                break;

            case 'real':
                ast.itype = "float";
                ast.ilocal = ieee754.llvm_float_hex(ast.val);
                break;
            case 'integer':
                ast.type.origname = 'INTEGER';
                ast.itype = "i32";
                ast.ilocal = ast.val;
                break;
            case 'character':
                ast.type.name = 'INTEGER';
                ast.type.origname = 'CHARACTER';
                ast.itype = "i8";
                ast.ilocal = ast.val;
                break;
            case 'string':
                var slen = ast.val.length+1,
                    re = /"/g,
                    itype = '[' + slen + ' x i8]',
                    sval = 'c"' + ast.val.replace(re, '\\22') + '\\00"',
                    lname = '%' + st.new_name('string' + str_cnt),
                    sname = '@.string' + (str_cnt++),
                    lname;
                ir.push([sname + ' = global ' + itype + ' ' + sval]);
                ir.push('  ' + lname + ' = getelementptr inbounds ' + itype + '* ' + sname + ', i32 0');
                ast.itype = itype + '*';
                ast.ilocal = lname;
                ast.istack = sname;
                break;
            case 'boolean':
                ast.itype = "i1";
                ast.ilocal = ast.val.toString();
                break;
            case 'pointer':
                if (ast.id.length === 1) {
                    try {
                        var pdecl = st.lookup(ast.id);
                    } catch(e) {
                        // HACK: we could't determine at normal parse time if this is
                        // a single character routine or if it's a control character
                        // literal. If it's a single character and defined in the
                        // symbol table then it's a pointer to a routine, otherwise
                        // it's a control character so update the AST (i.e. late
                        // parse)
                        switch (ast.id) {
                            case '@': ast.val = 0; break;
                            case 'G': ast.val = 7; break;
                            case 'H': ast.val = 8; break;
                            case 'I': ast.val = 9; break;
                            case 'J': ast.val = 10; break;
                            case 'L': ast.val = 12; break;
                            case 'M': ast.val = 13; break;
                            case '[': ast.val = 27; break;
                            case '?': ast.val = 127; break;
                            default: throw new Error("Unknown control character " + ast.id);
                        }
                        ast.node = 'character';
                        ast.type = {node:'type',name:'INTEGER',origname:'CHARACTER'};
                        ast.itype = "i8";
                        ast.ilocal = ast.val;
                        delete ast.id;
                    }
                }
                break;

            case 'variable':
                var vdecl;
                try {
                    vdecl = st.lookup(ast.id);
                } catch (e) {
                    vdecl = null;
                }

                if (vdecl && vdecl.fparams) {
                    // HACK: we could't determine at normal parse time if the ID
                    // is a normal ID or a parameter function call. If it's
                    // defined as a function, then assume this is actually
                    // a parameterless function call expression so replace the
                    // AST with a function and evalutate it
                    ast.node = 'expr_call';
                    ast.call_params = [];
                    ir.push.apply(ir, toIR(ast,level,fnames));
                    break;
                } else if (!vdecl) {
                    throw new Error("Variable '" + ast.id + "' not found in symbol table or in libraries");
                }

                vdecl.type = normalize_type(vdecl.type);
                var id = ast.id,
                    vtype = vdecl.type,
                    vlevel = vdecl.level,
                    lname = "%" + st.new_name(id + "_local");

                // Add variables from a higher lexical scope to our current
                // subprogram param list
                if (vlevel > 0 && level !== vlevel) {
                    // Variable is in higher lexical scope, simulate static
                    // link by passing the variable through intervening
                    // sub-programs
                    var new_pname, new_sname;
                    for(var l = vlevel+1; l <= level; l++) {
                        var fname = fnames[l],
                            pdecl = st.lookup(fname);
                        new_pname = "%" + st.new_name(id + "_lparam");
                        new_sname = new_pname + "_stack";
                        // replace vdecl and insert it at this level
                        vdecl = {node:'var_decl',type:vtype,pname:new_pname,sname:new_sname,var:true,lparam:true,level:l};
                        st.insert(id,vdecl,l);
                        // add the variable to the lparams (lexical variables)
                        pdecl.lparams.push({node:'variable',id:id,type:vtype});
                        st.replace(fname,pdecl);
                    }
                    ir.push('  ' + new_pname + ' = load ' + vtype.lltype + '* ' + new_sname + ' ; ' + l);
                    ast.ilocal = new_pname;
                    ast.istack = new_sname;
                }

                ir.push('  ' + lname + ' = load ' + vtype.lltype + '* ' + vdecl.sname);
                ast.type = vtype;
                ast.itype = vtype.lltype;
                ast.ilocal = lname;
                ast.istack = vdecl.sname;
                break;

            default:
                throw new Error("Unknown AST: " + JSON.stringify(ast));
        }

        return ir;
    }

    return {toIR: toIR,
        normalizeIR: normalizeIR,
        displayST: function() { st.display(); },
        getAST: function() { return theAST; }};
}

if (typeof module !== 'undefined') {
    var Parse = require('./parse'),
        ieee754 = require('./ieee754');

    exports.IR = IR;
    exports.toIR = function (ast) {
        var ir = new IR(ast);
        return ir.normalizeIR(ir.toIR());
    };

    exports.main = function commonjsMain(args) {
        if (!args[1]) {
            console.log('Usage: '+args[0]+' FILE');
            process.exit(1);
        }
        var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8"),
            ast = Parse.parser.parse(source);
        console.log(exports.toIR(ast));
    }
    if (require.main === module) {
        exports.main(process.argv.slice(1));
    }
}






function loadSourceFile(path) {
    var req = new XMLHttpRequest();
    req.onload = function() {
        var src = document.getElementById('the_source');
        src.innerHTML = req.responseText;
    }
    req.open("get", path);
    req.send();
}

var exampleFiles = {"Hello World":       "examples/hello.pas",
    "Fibonacci":         "tests/ffib.pas",
    "Quick Sort":        "tests/qsort.pas",
    "Nested Scope":      "tests/nested4.pas",
    "Hailstone Numbers": "examples/hailstone.pas",
    "JS Alert":          "examples/js_alert.pas",
    "JS Callback":       "examples/js_callback.pas"};
var sel = document.getElementById('source_file');

for (var k in exampleFiles) {
    var opt = document.createElement('option');
    opt.value = exampleFiles[k];
    opt.innerHTML = k;
    sel.appendChild(opt);
}

sel.onchange = function() { loadSourceFile(sel.value); };
loadSourceFile("examples/hello.pas");

// emscripten workarounds
arguments = [];

var Module = {};

// Keep LLVM.js from triggering browser print dialog
print = function () { };

// Monkey patch XMLHttpRequest open to be relative to XHR_PREFIX
(function(xhr) {
    var orig_open = xhr.open;
    xhr.open = function(method, url) {
        var rest = Array.prototype.slice.apply(arguments).slice(2);
        if (window.XHR_PREFIX && url.substr(0,4).toLowerCase() !== "http") {
            url = XHR_PREFIX + url;
        }
        return orig_open.apply(this, [method, url].concat(rest));
    };
})(XMLHttpRequest.prototype);

var XHR_PREFIX = ""

function doParse(src) {
    var source = src,
        parser = new parse.Parser(),
        ast = null;
    try {
        ast = parser.parse(source);
        return JSON.stringify(ast, null, 4);
    } catch (e) {
        return 'Error in parsing: ' + e;
    }
}

function doIR(src) {
    var json_ast = src,
        ast = JSON.parse(json_ast),
        IR_API = new IR(),
        ir = null;
    XHR_PREFIX = "";
    try {
        ir = IR_API.normalizeIR(IR_API.toIR(ast));
        return ir;
    } catch(e) {
        return 'Error compiling to IR: ' + e;
    }
}

function doOptimize(src) {
    XHR_PREFIX = "llvm.js/";
    var ir = src,
        new_ir = '', js = '';

    try {
        new_ir = llvmDis(llvmAs(ir));
        return new_ir;
    } catch (e) {
        return 'Error in compilation: ' + e;
    }
}

function doCompile(src) {
    XHR_PREFIX = "llvm.js/";
    var ir = src,
        js = '';

    try {
        compile(ir);
//    if (js && js[0] === 'E') {
//        throw new Error(js);
//    }
        return js;
    } catch (e) {
        return 'Error compiling to JS: ' + e;
    }
}

function doExecute(src) {
    XHR_PREFIX = "";
    var js = src;
    try {
        eval(js);
    } catch(e) {
        return 'Error in execution: ' + e;
    }
}




try {
    // On SpiderMonkey, prepare a large amount of GC space
    gcparam('maxBytes', 1024*1024*1024);
} catch(e) {}


// The environment setup code appears here, in js_optimizer.js and in tests/hello_world.js because it can't be shared. Keep them in sync!
// It also appears, in modified form, in shell.js.
// *** Environment setup code ***
var arguments_ = [];

var ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function';
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {
    // Expose functionality in the same simple way that the shells work
    // Note that we pollute the global namespace here, otherwise we break in node
    print = function(x) {
        process['stdout'].write(x + '\n');
    };
    printErr = function(x) {
        process['stderr'].write(x + '\n');
    };

    var nodeFS = require('fs');
    var nodePath = require('path');

    if (!nodeFS.existsSync) {
        nodeFS.existsSync = function(path) {
            try {
                return !!nodeFS.readFileSync(path);
            } catch(e) {
                return false;
            }
        }
    }

    function find(filename) {
        var prefixes = [__dirname, process.cwd()];
        for (var i = 0; i < prefixes.length; ++i) {
            var combined = nodePath.join(prefixes[i], filename);
            if (nodeFS.existsSync(combined)) {
                return combined;
            }
        }
        return filename;
    }

    read = function(filename) {
        var absolute = find(filename);
        return nodeFS['readFileSync'](absolute).toString();
    };

    load = function(f) {
        globalEval(read(f));
    };

    arguments_ = process['argv'].slice(2);

} else if (ENVIRONMENT_IS_SHELL) {
    // Polyfill over SpiderMonkey/V8 differences
    if (!this['read']) {
        this['read'] = function(f) { snarf(f) };
    }

    if (typeof scriptArgs != 'undefined') {
        arguments_ = scriptArgs;
    } else if (typeof arguments != 'undefined') {
        arguments_ = arguments;
    }

} else if (ENVIRONMENT_IS_WEB) {
    printErr = function(x) {
        console.log(x);
    };

    if (!this['print']) this['print'] = printErr;

    this['read'] = function(url) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.send(null);
        return xhr.responseText;
    };

    if (this['arguments']) {
        arguments_ = arguments;
    }
} else if (ENVIRONMENT_IS_WORKER) {
    // We can do very little here...

    this['load'] = importScripts;

} else {
    throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
    eval.call(null, x);
}

if (typeof load == 'undefined' && typeof read != 'undefined') {
    this['load'] = function(f) {
        globalEval(read(f));
    };
}

if (typeof printErr === 'undefined') {
    this['printErr'] = function(){};
}

if (typeof print === 'undefined') {
    this['print'] = printErr;
}
// *** Environment setup code ***


// Basic utilities

load('utility.js');

// Load settings, can be overridden by commandline

load('settings.js');

var settings_file = arguments_[0];
var ll_file = arguments_[1];
phase = arguments_[2];
if (phase == 'pre') {
    additionalLibraries = Array.prototype.slice.call(arguments_, 3);
} else {
    var forwardedDataFile = arguments_[3];
    additionalLibraries = Array.prototype.slice.call(arguments_, 4);
}

if (settings_file) {
    var settings = JSON.parse(read(settings_file));
    for (setting in settings) {
        eval(setting + ' = ' + JSON.stringify(settings[setting]));
    }
}


if (CORRECT_SIGNS >= 2) {
    CORRECT_SIGNS_LINES = set(CORRECT_SIGNS_LINES); // for fast checking
}
if (CORRECT_OVERFLOWS >= 2) {
    CORRECT_OVERFLOWS_LINES = set(CORRECT_OVERFLOWS_LINES); // for fast checking
}
if (CORRECT_ROUNDINGS >= 2) {
    CORRECT_ROUNDINGS_LINES = set(CORRECT_ROUNDINGS_LINES); // for fast checking
}
if (SAFE_HEAP >= 2) {
    SAFE_HEAP_LINES = set(SAFE_HEAP_LINES); // for fast checking
}

if (PGO) { // by default, correct everything during PGO
    CORRECT_SIGNS = CORRECT_SIGNS || 1;
    CORRECT_OVERFLOWS = CORRECT_OVERFLOWS || 1;
    CORRECT_ROUNDINGS = CORRECT_ROUNDINGS || 1;
}

EXPORTED_FUNCTIONS = set(EXPORTED_FUNCTIONS);
EXPORTED_GLOBALS = set(EXPORTED_GLOBALS);

RUNTIME_DEBUG = LIBRARY_DEBUG || GL_DEBUG;

// Settings sanity checks

assert(!(USE_TYPED_ARRAYS === 2 && QUANTUM_SIZE !== 4), 'For USE_TYPED_ARRAYS == 2, must have normal QUANTUM_SIZE of 4');

// Output some info and warnings based on settings

if (!MICRO_OPTS || !RELOOP || ASSERTIONS || CHECK_SIGNS || CHECK_OVERFLOWS || INIT_STACK || INIT_HEAP ||
    !SKIP_STACK_IN_SMALL || SAFE_HEAP || PGO || PROFILE || !DISABLE_EXCEPTION_CATCHING) {
    print('// Note: Some Emscripten settings will significantly limit the speed of the generated code.');
} else {
    print('// Note: For maximum-speed code, see "Optimizing Code" on the Emscripten wiki, https://github.com/kripken/emscripten/wiki/Optimizing-Code');
}

if (DOUBLE_MODE || CORRECT_SIGNS || CORRECT_OVERFLOWS || CORRECT_ROUNDINGS) {
    print('// Note: Some Emscripten settings may limit the speed of the generated code.');
}

// Load compiler code

load('framework.js');
load('modules.js');
load('parseTools.js');
load('intertyper.js');
load('analyzer.js');
load('jsifier.js');
if (RELOOP) load('relooper.js')
globalEval(processMacros(preprocess(read('runtime.js'))));
Runtime.QUANTUM_SIZE = QUANTUM_SIZE;

var temp = {};
for (var i = 0; i < NECESSARY_BLOCKADDRS.length; i++) {
    var func = toNiceIdent(NECESSARY_BLOCKADDRS[i][0]);
    var label = toNiceIdent(NECESSARY_BLOCKADDRS[i][1]);
    if (!temp[func]) temp[func] = {};
    temp[func][label] = 1;
}
NECESSARY_BLOCKADDRS = temp;

//===============================
// Main
//===============================

// Read llvm

function compile(raw) {
    if (FAKE_X86_FP80) {
        raw = raw.replace(/x86_fp80/g, 'double');
    }
    if (raw.search('\r\n') >= 0) {
        raw = raw.replace(/\r\n/g, '\n'); // fix windows line endings
    }
    var lines = raw.split('\n');
    raw = null;

    // Pre-process the LLVM assembly

    Debugging.handleMetadata(lines);

    function runPhase(currPhase) {
        //printErr('// JS compiler in action, phase ' + currPhase + typeof lines + (lines === null));
        phase = currPhase;
        if (phase != 'pre') {
            if (singlePhase) PassManager.load(read(forwardedDataFile));

            if (phase == 'funcs') {
                PreProcessor.eliminateUnneededIntrinsics(lines);
            }
        }

        // Do it

        var intertyped = intertyper(lines);
        if (singlePhase) lines = null;
        var analyzed = analyzer(intertyped);
        intertyped = null;
        JSify(analyzed);

        phase = null;

        if (DEBUG_MEMORY) {
            print('zzz. last gc: ' + gc());
            MemoryDebugger.dump();
            print('zzz. hanging now!');
            while(1){};
        }
    }

    // Normal operation is for each execution of compiler.js to run a single phase. The calling script sends us exactly the information we need, and it is easy to parallelize operation that way. However, it is also possible to run in an unoptimal multiphase mode, where a single invocation goes from ll to js directly. This is not recommended and will likely do a lot of duplicate processing.
    singlePhase = !!phase;

    if (singlePhase) {
        runPhase(phase);
    } else {
        runPhase('pre');
        runPhase('funcs');
        runPhase('post');
    }
}

if (ll_file) {
    if (ll_file.indexOf(String.fromCharCode(10)) == -1) {
        compile(read(ll_file));
    } else {
        compile(ll_file); // we are given raw .ll
    }
}






const TelegramBot = require('node-telegram-bot-api')

const TOKEN = '582781742:AAEdHk29QT-MAYqG8697qjocsY5hOUnzqgk'

const bot = new TelegramBot(TOKEN, {polling: true})

bot.on('message', msg => {
    var GetText = msg.text;
    var ParseText = doParse(GetText);
    bot.sendMessage(msg.chat.id, 'Parsing result: ');
    bot.sendMessage(msg.chat.id, ParseText);
    var IRText = doIR(ParseText);
    bot.sendMessage(msg.chat.id, 'IR result: ');
    bot.sendMessage(msg.chat.id, IRText);
    var OptimizeText = doOptimize(IRText);
    bot.sendMessage(msg.chat.id, 'Optimize result: ');
    bot.sendMessage(msg.chat.id, OptimizeText);
    var CompileText = doCompile(OptimizeText);
    bot.sendMessage(msg.chat.id, 'Compile result: ');
    bot.sendMessage(msg.chat.id, CompileText);
    var ExecuteText = doExecute(CompileText);
    bot.sendMessage(msg.chat.id, 'Execute result: ');
    bot.sendMessage(msg.chat.id, ExecuteText);
})

